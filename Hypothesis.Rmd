---
title: "PM606 Project"
author: "Allison Louie"
date: "2024-06-06"
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
    code_folding: hide
---

```{r setup, include=FALSE}
library(knitr)
library(dplyr)
library(summarytools)
library(kableExtra)
library(tidyverse)
library(Biobase)
library(plotly)
library(corrplot)
library(table1)
library(randomForest)
library(caret)
library(nnet)
library(gbm)
library(grpreg)
library(glmnet)
library(cluster)
library(factoextra)
library(Hmisc)
options(knitr.table.format = "html")
knitr::opts_chunk$set(echo = TRUE)
work.dir <- here::here()
old.warn <- getOption("warn")
options(warn=-1)
```

# Hypothesis

Postnatal environmental exposures, particularly those found in household products and dietary intake, along with specific serum metabolomics profiles, are significantly associated with the BMI Z-score of children aged 6-11 years. Higher concentrations of certain metabolites in serum, reflecting exposure to chemical classes or metals, will correlate with variations in BMI Z-score, controlling for age and other relevant covariates. Some metabolites associated with chemical exposures and dietary patterns can serve as biomarkers for the risk of developing obesity.

# Background

Research indicates that postnatal exposure to endocrine-disrupting chemicals (EDCs) such as phthalates, bisphenol A (BPA), and polychlorinated biphenyls (PCBs) can significantly influence body weight and metabolic health ([Junge et al., 2018](https://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-018-0478-z)). These chemicals, commonly found in household products and absorbed through dietary intake, are linked to detrimental effects on body weight and metabolic health in children. This hormonal interference can lead to an increased body mass index (BMI) in children, suggesting a potential pathway through which exposure to these chemicals contributes to the development of obesity.

A longitudinal study on Japanese children examined the impact of postnatal exposure (first two years of life) to p,p’*-*dichlorodiphenyltrichloroethane (p,p’*-*DDT) and p,p’*-*dichlorodiphenyldichloroethylene (p,p’*-*DDE) through breastfeeding ([Plouffe et al., 2020](https://ehjournal.biomedcentral.com/articles/10.1186/s12940-020-00603-z)). The findings revealed that higher levels of these chemicals in breast milk were associated with increased BMI at 42 months of age. DDT and DDE may interfere with hormonal pathways related to growth and development. These chemicals can mimic or disrupt hormones that regulate metabolism and fat accumulation. This study highlights the importance of understanding how persistent organic pollutants can affect early childhood growth and development.

The study by [Harley et al. (2013)](https://pubmed.ncbi.nlm.nih.gov/23416456/) investigates the association between prenatal and postnatal Bisphenol A (BPA) exposure and various body composition metrics in children aged 9 years from the CHAMACOS cohort. The study found that higher prenatal BPA exposure was linked to a decrease in BMI and body fat percentages in girls but not boys, suggesting sex-specific effects. Conversely, BPA levels measured at age 9 were positively associated with increased adiposity in both genders, highlighting the different impacts of exposure timing on childhood development.

The 2022 study [2022 study by Uldbjerg et al.](https://academic.oup.com/humupd/article/28/5/687/6573218) explored the effects of combined exposures to multiple EDCs, suggesting that mixtures of these chemicals can have additive or synergistic effects on BMI and obesity risk. Humans are typically exposed to a mixture of chemicals rather than individual EDCs, making it crucial to understand how these mixtures might interact. The research highlighted that the interaction between different EDCs can lead to additive (where the effects simply add up) or even synergistic (where the combined effect is greater than the sum of their separate effects) outcomes. These interactions can significantly amplify the risk factors associated with obesity and metabolic disorders in children. The dose-response relationship found that even low-level exposure to multiple EDCs could result in significant health impacts due to their combined effects.

These studies collectively illustrate the critical role of environmental EDCs in shaping metabolic health outcomes in children, highlighting the necessity for ongoing research and policy intervention to mitigate these risks.

# Data Description

This study will utilize data from the subcohort of 1301 mother-child pairs in the HELIX study, who are which aged 6-11 years for whom complete exposure and outcome data were available. Exposure data included detailed dietary records after pregnancy  and concentrations of various chemicals like BPA and PCBs in child blood samples. There are categorical and numerical variables, which will include both demographic details and biochemical measurements. This dataset allows for robust statistical analysis to identify potential associations between EDC exposure and changes in BMI Z-scores, considering confounding factors such as age, gender, and socioeconomic status. There are no missing data so there is not need to impute the information. Child BMI Z-scores were calculated based on WHO growth standards.

```{r load data and codebook, echo=TRUE}
load("/Users/allison/Library/CloudStorage/GoogleDrive-aflouie@usc.edu/My Drive/HELIX_data/HELIX.RData")
filtered_chem_diet <- codebook %>%
  filter(domain %in% c("Chemicals", "Lifestyles") & period == "Postnatal" & subfamily != "Allergens")

# specific covariates
filtered_covariates <- codebook %>%
  filter(domain == "Covariates" & 
         variable_name %in% c("e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None"))

#specific phenotype variables
filtered_phenotype <- codebook %>%
  filter(domain == "Phenotype" & 
         variable_name %in% c("hs_zbmi_who"))

# combining all necessary variables together
combined_codebook <- bind_rows(filtered_chem_diet, filtered_covariates, filtered_phenotype)
kable(combined_codebook, align = "c", format = "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

## Data Summary for Exposures, Covariates, and Outcome {.tabset}

### Data Summary Exposures: Lifestyles

```{r Lifestyles summary, attr.output='style="max-height: 100px;"',}
Lifestyle_Exposures <- combined_codebook$variable_name[combined_codebook$domain=="Lifestyles"]
lifestyle_exposome <- dplyr::select(exposome, all_of(Lifestyle_Exposures))
summarytools::view(dfSummary(lifestyle_exposome, style = 'grid', plain.ascii = FALSE, valid.col = FALSE, headings = FALSE), method = "render")
```

```{r}
#separate numeric and categorical data
numeric_lifestyle <- lifestyle_exposome %>% 
  dplyr::select(where(is.numeric))

numeric_lifestyle_long <- pivot_longer(
  numeric_lifestyle,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_numerical_vars <- unique(numeric_lifestyle_long$variable)

num_plots <- lapply(unique_numerical_vars, function(var) {
  data <- filter(numeric_lifestyle_long, variable == var)
  p <- ggplot(data, aes(x = value)) +
    geom_histogram(bins = 30, fill = "blue") +
    labs(title = paste("Histogram of", var), x = "Value", y = "Count")
  print(p)
  return(p)
})
```

The Sum of KIDMED indices, without index9 histogram displays a multimodal distribution with peaks primarily at scores 0, 3, 5, 7, and 10. This suggests that the dataset has several subgroups within the population, each characterized by distinct dietary habits or patterns as measured by the KIDMED index, which assesses adherence to the Mediterranean diet. The distribution is discrete, reflecting integer scores that children have received based on their dietary intake. The modes indicate the most common dietary patterns, suggesting possible clusters of dietary behavior among the children sampled.

The second histogram depicts the distribution of clean and over-reported moderate-to-vigorous physical activity (MVPA) in minutes per day. This histogram shows a right-skewed distribution, indicating that most children report lower levels of physical activity, with a smaller number of children reporting very high levels of activity, which might be over-reported. The peak near the lower end suggests that a significant portion of the sample engages in minimal to moderate amounts of MVPA, while the long tail to the right hints at a few cases with unusually high reported values, possibly due to over-reporting or measurement errors in data collection.

For sedentary behavior in minutes per day, there is a distribution that is slightly left-skewed in the histogram. Most children tend to have higher sedentary time, with a concentration of values towards the right side of the histogram. The distribution suggests that fewer children engage in lower levels of sedentary behavior, indicating a trend towards more inactivity among the sample. This pattern might raise concerns regarding lifestyle habits that contribute to prolonged periods of low physical activity.

The distribution of total hours of sleep per night (averaged over weekdays and weekends) exhibits a nearly normal distribution. This suggests that most children in the study have a consistent sleep duration with the bulk of the data clustering around the mean. The symmetry of the distribution indicates a healthy variance in sleep hours among the children, without significant extremes in either insufficient or excessive sleep, which is a positive indication of regular sleep patterns in this population.

```{r}
categorical_lifestyle <- lifestyle_exposome %>% 
  dplyr::select(where(is.factor))

categorical_lifestyle_long <- pivot_longer(
  categorical_lifestyle,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_categorical_vars <- unique(categorical_lifestyle_long$variable)
categorical_plots <- lapply(unique_categorical_vars, function(var) {
  data <- filter(categorical_lifestyle_long, variable == var)
  
  p <- ggplot(data, aes(x = value, fill = value)) +
    geom_bar(stat = "count") +
    labs(title = paste("Distribution of", var), x = var, y = "Count")
  
  print(p)
  return(p)
})
```

Breastfeeding Duration: Majority of observations are in the highest duration category, suggesting longer breastfeeding periods are common.

Bakery Products: Shows a relatively even distribution across the three categories, indicating varied consumption levels of bakery products among participants.

Beverages: A significant number of participants consume beverages at the highest level, indicating a preference or higher consumption of beverages like sodas.

Breakfast Cereal: The highest category of cereal consumption is the most common, suggesting a preference for or greater consumption of cereals.

Caffeinated/Energy Drinks: Displays a high number of participants avoiding or consuming very low quantities of caffeinated or energy drinks.

Dairy: Shows a fairly even distribution across all categories, indicating a uniform consumption pattern of dairy products.

Fast Food: Most participants fall into the middle category, indicating moderate consumption of fast food.

Organic Food: Most participants either consume a lot of or no organic food, with fewer in the middle range.

Processed Meat: Consumption levels are fairly evenly distributed, indicating varied dietary habits regarding processed meats.

Ready-Made Meals: Many participants rarely consume ready-made meals, with a significant number also in the highest consumption category.

Bread: Distribution shows a significant leaning towards higher bread consumption.

Cereal: Even distribution across categories suggests varied cereal consumption habits.

Fish and Seafood: Even distribution across categories, indicating varied consumption of fish and seafood.

Fruits: High fruit consumption is the most common, with fewer participants in the lowest category.

Added Fats: More participants consume added fats at the lowest and highest levels, with fewer in the middle.

Meat: Consumption of meat is highest in the middle category.

Potatoes: Shows a tendency towards either low or high consumption, with fewer people in the middle range.

Sweets: High consumption of sweets is the most common, indicating a preference for or higher access to sugary foods.

Vegetables: Most participants consume a high amount of vegetables.

Yogurt: Shows a preference for either very high or very low yogurt consumption, with fewer participants in the middle.


```{r}
numeric_lifestyle <- select_if(lifestyle_exposome, is.numeric)
cor_matrix <- cor(numeric_lifestyle, method = "pearson")
cor_matrix <- cor(numeric_lifestyle, method = "spearman")
corrplot(cor_matrix, method = "circle")
```

### Data Summary Exposures: Chemicals

```{r Chemicals summary, attr.output='style="max-height: 100px;"',}
Chemical_Exposures <- combined_codebook$variable_name[combined_codebook$domain=="Chemicals"]
chemical_exposome <- exposome %>%
  dplyr::select(all_of(Chemical_Exposures))
summarytools::view(dfSummary(chemical_exposome, style = 'grid', plain.ascii = FALSE, valid.col = FALSE, headings = FALSE), method = "render")
```

```{r}
#separate numeric and categorical data
numeric_chemical <- chemical_exposome %>% 
  dplyr::select(where(is.numeric))

numeric_chemical_long <- pivot_longer(
  numeric_chemical,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_numerical_vars <- unique(numeric_chemical_long$variable)

num_plots <- lapply(unique_numerical_vars, function(var) {
  data <- filter(numeric_chemical_long, variable == var)
  p <- ggplot(data, aes(x = value)) +
    geom_histogram(bins = 30, fill = "blue") +
    labs(title = paste("Histogram of", var), x = "Value", y = "Count")
  print(p)
  return(p)
})
```

Arsenic (hs_as_c_Log2): This histogram shows a bimodal distribution of arsenic levels, with two prominent peaks. Such a distribution might suggest two different populations or sources of exposure among the study participants.

Cadmium (hs_cd_c_Log2): The distribution of cadmium levels is skewed to the right, indicating that most participants have lower exposure levels, with a few cases showing significantly higher exposures.

Cobalt (hs_co_c_Log2): The histogram of cobalt levels displays a roughly normal distribution centered around a slight positive skew. This suggests a common source of exposure with varying levels among the population.

Cesium (hs_cs_c_Log2): Exhibits a right-skewed distribution, indicating that most participants have relatively low exposure levels, but a small number have substantially higher exposures.

Copper (hs_cu_c_Log2): Shows a right-skewed distribution, suggesting that while most individuals have moderate exposure, a few experience significantly higher levels of copper.

Mercury (hs_hg_c_Log2): This distribution is also right-skewed, common for environmental pollutants, where a majority have lower exposure levels, and a minority have high exposure levels.

Manganese (hs_mn_c_Log2): The histogram for manganese displays a bell-shaped distribution, indicating a normal distribution of manganese levels among the participants.

Molybdenum (hs_mo_c_Log2): Shows a distribution with a sharp peak and a long right tail, suggesting that while most people have similar exposure levels, a few have exceptionally high exposures.

Lead (hs_pb_c_Log2): The distribution is slightly right-skewed, indicating higher exposure levels in a smaller group of the population compared to the majority.

DDE (hs_dde_cadj_Log2): Shows a pronounced right skew, typical for chemicals that accumulate in the environment and in human tissues, indicating higher levels of exposure in a smaller subset of the population.

DDT (hs_ddt_cadj_Log2): This histogram displays a multi-modal distribution, suggesting different sources or durations of exposure among the population.

Hexachlorobenzene (hs_hcb_cadj_Log2): Exhibits a right-skewed distribution with a long tail, indicating that most people have lower exposure levels with some outliers experiencing very high exposures.

PCB 118, 138, 153 (hs_pcb118_cadj_Log2, hs_pcb138_cadj_Log2, hs_pcb153_cadj_Log2): All three PCBs show similar distributions with right skewness, suggesting that exposure to these compounds is higher among a smaller segment of the population.

PCB 170 and PCB 180: Both histograms show a significant right skew, indicating lower concentrations of these chemicals in most samples, with fewer samples showing higher concentrations. This pattern suggests that while most individuals have low exposure, a few may have considerably higher levels.

Sum of PCBs: The histogram is approximately normally distributed, centered around a higher value compared to individual PCBs, indicating a collective higher average exposure when all measured PCBs are considered together.

DEP, DETP, DMTP, DMDTP, PBDE 153, and PBDE 47: These histograms mostly show multimodal distributions (more than one peak), suggesting different exposure sources or groups within the population that have distinct exposure levels. The multiple peaks could indicate varied exposure pathways or differences in how these chemicals are metabolized or retained in the body.

PFHxS, PFNA, and PFOA: These perfluorinated compounds display a roughly normal distribution skewed right, suggesting a common source of exposure among the population, but with some individuals experiencing higher exposures.

PFOS and PFUnDA: The histograms show a single, sharp peak with a rapid decline, indicating that most individuals have similar exposure levels, likely due to common environmental sources or regulatory controls limiting variability.

BPA: The histogram is sharply peaked near zero with a long tail to the right, indicating low exposure for most individuals but significant exposure for a few, possibly due to specific product use or occupational exposure.

MBZP (Monobenzyl Phthalate): This histogram shows a right-skewed distribution. Most values cluster at the lower end, indicating a common lower exposure level among subjects, with a long tail towards higher values suggesting occasional higher exposures.

MECPP (Mono-ethyl hexyl phthalate): The distribution is right-skewed, similar to MBZP, but with a smoother decline. This pattern also indicates that while most subjects have lower exposure levels, a few experience significantly higher exposures.

MEHHP (Mono-2-ethyl-5-hydroxyhexyl phthalate): Exhibits a unimodal distribution with a peak around a middle value and symmetric tails. This could indicate a more standardized exposure level among the subjects with some variation.

MEHP (Mono-ethylhexyl phthalate):Another right-skewed distribution, indicating that most subjects have lower exposure levels but a few have much higher levels.

MEOHP (Mono-2-ethyl-5-oxohexyl phthalate): This histogram shows a distribution with a peak around the middle values and a tail extending towards higher values, suggesting a central tendency with some higher exposures.

MEP (Mono-ethyl phthalate): The distribution is right-skewed, similar to others, showing most subjects with low to moderate levels of exposure, but a few have much higher levels.

OXINP (Oxidized Isoparaffin): This histogram shows a central peak with a fast decline, indicating a concentration of values around a specific point which might suggest a common exposure level among the subjects.

Sum of DEHP Metabolites: This shows a broad distribution with a peak towards the lower end, indicating varied exposure levels among the subjects, with most experiencing lower exposures.

Personal Care Product Use: The histogram displays a highly skewed distribution with multiple peaks, reflecting varied usage patterns among subjects, with some showing particularly high usage levels.

```{r}
categorical_chemical <- chemical_exposome %>% 
  dplyr::select(where(is.factor))

categorical_chemical_long <- pivot_longer(
  categorical_chemical,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_categorical_vars <- unique(categorical_chemical_long$variable)
categorical_plots <- lapply(unique_categorical_vars, function(var) {
  data <- filter(categorical_chemical_long, variable == var)
  
  p <- ggplot(data, aes(x = value, fill = value)) +
    geom_bar(stat = "count") +
    labs(title = paste("Distribution of", var), x = var, y = "Count")
  
  print(p)
  return(p)
})
```

hs_t_cdich_None (Detected vs. Undetected):The vast majority of samples were undetected for this particular chemical, with only a small fraction showing detection.

hs_dmdtp_cdich_None (Detected vs. Undetected): Similar to the previous, most samples were undetected, but a higher proportion shows detection compared to the first chemical.

FAS_cat_None (Family Affluence Scale categories - Low, Middle, High): This shows the distribution of family affluence categories where the largest group is the high affluence, followed by middle, with the fewest in the low category.

hs_contactfam_3cat_num_None (Frequency of contact with family): Most individuals reported daily (almost daily) contact with family, a smaller number reported weekly contact, and the fewest reported less frequent than weekly contact.

hs_participation_3cat_None (Participation in organisations): A large number of individuals do not participate in any organisation, a substantial number participate in one, and a smaller group in two or more.

hs_cotinine_cdich_None (Detected vs. Undetected): Cotinine detection is high, indicating exposure to nicotine, with a significant number of samples showing detection versus undetected.

hs_globalexp2_None (Global Exposure - Exposure vs. No Exposure): This represents overall exposure to some condition or factor, with a larger proportion having no exposure compared to those with exposure.

hs_smk_parents_None (Smoking status of parents - Both, Neither, One): The largest group reported that neither parent smokes, a significant number reported one smoking parent, and the smallest group reported both parents smoke.

```{r}
numeric_chemical <- select_if(chemical_exposome, is.numeric)
cor_matrix <- cor(numeric_chemical, method = "pearson")
cor_matrix <- cor(numeric_chemical, method = "spearman")
custom_color_scale <- list(
  c(0, "darkred"),    
  c(0.5, "white"), 
  c(1, "darkblue")
)

plot_ly(
  z = cor_matrix, 
  x = colnames(cor_matrix), 
  y = colnames(cor_matrix), 
  type = "heatmap",
  colorscale = custom_color_scale
) %>%
layout(
  title = "Correlation Matrix",
  xaxis = list(tickangle = -90),
  yaxis = list(side = "left")
)
```

### Data Summary Covariates

```{r covariate summary, results='asis'}
summarytools::view(dfSummary(covariates, style = 'grid', plain.ascii = FALSE, valid.col = FALSE, headings = FALSE), method = "render")
```

```{r}
#separate numeric and categorical data
numeric_covariates <- covariates %>% 
  dplyr::select(where(is.numeric))

numeric_covariates_long <- pivot_longer(
  numeric_covariates,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_numerical_vars <- unique(numeric_covariates_long$variable)

num_plots <- lapply(unique_numerical_vars, function(var) {
  data <- filter(numeric_covariates_long, variable == var)
  p <- ggplot(data, aes(x = value)) +
    geom_histogram(bins = 30, fill = "blue") +
    labs(title = paste("Histogram of", var), x = "Value", y = "Count")
  print(p)
  return(p)
})
```

ID: This histogram appears to show a uniform distribution of IDs over a range, with all IDs evenly spaced. This typical pattern is expected in a dataset where IDs are systematically assigned.

Maternal BMI (h_mbmi): The distribution of maternal BMI is roughly normal but slightly right-skewed, indicating that more individuals are on the higher side of the BMI scale. The peak of the histogram around the 25-30 range suggests a concentration of values in this area, which is typical for adult populations.

Weight Gain (hs_wgtgain): This histogram displays a bimodal distribution of weight gain, with significant peaks around 10 and another around 20. This could indicate two common patterns or recommendations in weight gain during pregnancy or another health-related period.

Gestational Age at Childbirth (e3_gac): The distribution is centered around the 40-week mark, which is typical for full-term pregnancies. There is a sharp peak at around 40 weeks, showing that most childbirths occur at this gestational age.

Maternal Age (h_age): This histogram shows a roughly normal distribution with a peak around the early 30s, suggesting that this is the most common age range for the mothers in the dataset.

Child's Age (hs_child_age): This histogram is multimodal, reflecting several peaks across different ages. This could be indicative of the data collection points or particular age groups being studied.

Child's Height (hs_c_height): The data is approximately normally distributed with a slight right skew. The majority of the measurements cluster around the mean, which suggests typical growth patterns.

Child's Weight (hs_c_weight): This histogram is right-skewed, indicating that while most children's weights are within a normal range, there is a long tail of children who weigh more, which might suggest variations in growth or cases of overweight.

```{r}
categorical_covariates <- covariates %>% 
  dplyr::select(where(is.factor))

categorical_covariates_long <- pivot_longer(
  categorical_covariates,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_categorical_vars <- unique(categorical_covariates_long$variable)
categorical_plots <- lapply(unique_categorical_vars, function(var) {
  data <- filter(categorical_covariates_long, variable == var)
  
  p <- ggplot(data, aes(x = value, fill = value)) +
    geom_bar(stat = "count") +
    labs(title = paste("Distribution of", var), x = var, y = "Count")
  
  print(p)
  return(p)
})
```

Cohorts (h_cohort): The distribution shows the count of subjects across six different cohorts. All cohorts have a substantial number of subjects, with cohort 5 showing the highest participation.

Gender Distribution (e3_sex): The gender distribution is nearly balanced with a slight higher count for males compared to females.

Year of Birth (e3_yearbir): This chart shows that the majority of subjects were born in the later years, with a significant increase in 2009, indicating perhaps a larger recruitment or a specific cohort focus that year.

Educational Level (h_educmc): Represents three categories of educational attainment, with category 3 having the highest count, suggesting a higher level of education among the majority of the subjects.

Native Language (h_native): Shows the count of parents by their native country status. The majority are from category 2.

Parity (h_parity): The chart categorizes subjects based on the number of children they have. The largest group is those with no children, followed by those with one child, and a smaller group with two children.


```{r}
numeric_covariate <- select_if(covariates, is.numeric)
cor_matrix <- cor(numeric_covariate, method = "pearson")
cor_matrix <- cor(numeric_covariate, method = "spearman")
corrplot(cor_matrix, method = "circle")
```

### Data Summary Outcome: Phenotype

```{r phenotype summary}
outcome_BMI <- phenotype %>% 
  dplyr::select(hs_zbmi_who, hs_bmi_c_cat)
summarytools::view(dfSummary(outcome_BMI, style = 'grid', plain.ascii = FALSE, valid.col = FALSE, headings = FALSE), method = "render")
```

# Models to Consider

```{r}
outcome_cov <- cbind(covariates, outcome_BMI)
outcome_cov <- outcome_cov[, !duplicated(colnames(outcome_cov))]
outcome_cov <- outcome_cov %>%
  dplyr::select(hs_child_age_None, h_cohort, e3_sex_None, e3_yearbir_None, h_edumc_None, h_native_None, hs_zbmi_who)
summary_table <- dfSummary(outcome_cov, 
                           varnumbers = TRUE, 
                           valid.col = FALSE, 
                           graph.col = TRUE, 
                           style = "multiline")

print(summary_table, method = "render", plain.ascii = FALSE, style = "grid")
```

```{r}
#the full chemicals list
chemicals_full <- c(
  "hs_as_c_Log2",
  "hs_cd_c_Log2",
  "hs_co_c_Log2",
  "hs_cs_c_Log2",
  "hs_cu_c_Log2",
  "hs_hg_c_Log2",
  "hs_mn_c_Log2",
  "hs_mo_c_Log2",
  "hs_pb_c_Log2",
  "hs_tl_cdich_None",
  "hs_dde_cadj_Log2",
  "hs_ddt_cadj_Log2",
  "hs_hcb_cadj_Log2",
  "hs_pcb118_cadj_Log2",
  "hs_pcb138_cadj_Log2",
  "hs_pcb153_cadj_Log2",
  "hs_pcb170_cadj_Log2",
  "hs_pcb180_cadj_Log2",
  "hs_dep_cadj_Log2",
  "hs_detp_cadj_Log2",
  "hs_dmdtp_cdich_None",
  "hs_dmp_cadj_Log2",
  "hs_dmtp_cadj_Log2",
  "hs_pbde153_cadj_Log2",
  "hs_pbde47_cadj_Log2",
  "hs_pfhxs_c_Log2",
  "hs_pfna_c_Log2",
  "hs_pfoa_c_Log2",
  "hs_pfos_c_Log2",
  "hs_pfunda_c_Log2",
  "hs_bpa_cadj_Log2",
  "hs_bupa_cadj_Log2",
  "hs_etpa_cadj_Log2",
  "hs_mepa_cadj_Log2",
  "hs_oxbe_cadj_Log2",
  "hs_prpa_cadj_Log2",
  "hs_trcs_cadj_Log2",
  "hs_mbzp_cadj_Log2",
  "hs_mecpp_cadj_Log2",
  "hs_mehhp_cadj_Log2",
  "hs_mehp_cadj_Log2",
  "hs_meohp_cadj_Log2",
  "hs_mep_cadj_Log2",
  "hs_mibp_cadj_Log2",
  "hs_mnbp_cadj_Log2",
  "hs_ohminp_cadj_Log2",
  "hs_oxominp_cadj_Log2",
  "FAS_cat_None",
  "hs_contactfam_3cat_num_None",
  "hs_hm_pers_None",
  "hs_participation_3cat_None",
  "hs_cotinine_cdich_None",
  "hs_globalexp2_None",
  "hs_smk_parents_None"
)

#postnatal diet for child
postnatal_diet <- c(
  "h_bfdur_Ter",
  "hs_bakery_prod_Ter",
  "hs_beverages_Ter",
  "hs_break_cer_Ter",
  "hs_caff_drink_Ter",
  "hs_dairy_Ter",
  "hs_fastfood_Ter",
  "h_legume_preg_Ter",
  "hs_org_food_Ter",
  "hs_proc_meat_Ter",
  "hs_readymade_Ter",
  "hs_total_bread_Ter",
  "hs_total_cereal_Ter",
  "hs_total_fish_Ter",
  "hs_total_fruits_Ter",
  "hs_total_lipids_Ter",
  "hs_total_meat_Ter",
  "hs_total_potatoes_Ter",
  "hs_total_sweets_Ter",
  "hs_total_veg_Ter",
  "hs_total_yog_Ter"
)

all_columns <- c(chemicals_full, postnatal_diet)
extracted_exposome <- exposome %>% dplyr::select(all_of(all_columns))
head(extracted_exposome)
```

## Final Selected Data

```{r}
selected_data <- cbind(outcome_cov, extracted_exposome)
head(selected_data)
```

```{r}
selected_data_corr <- select_if(selected_data, is.numeric)
cor_matrix <- cor(selected_data_corr, method = "pearson")
cor_matrix <- cor(selected_data_corr, method = "spearman")
custom_color_scale <- list(
  c(0, "darkred"),    
  c(0.5, "white"), 
  c(1, "darkblue")
)

plot_ly(
  z = cor_matrix, 
  x = colnames(cor_matrix), 
  y = colnames(cor_matrix), 
  type = "heatmap",
  colorscale = custom_color_scale
) %>%
layout(
  title = "Correlation Matrix",
  xaxis = list(tickangle = -90),
  yaxis = list(side = "left")
)
```

## Comparing Models with and without Covariates

### Chemicals Data

```{r, warning=FALSE}
chemical_data_only <- selected_data[, chemicals_full]
covariate_names <- c("e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None")
covariates_data <- selected_data[, covariate_names]

# selected and outcome variable
x <- as.matrix(selected_data[, setdiff(names(selected_data), "hs_zbmi_who")])
y <- selected_data$hs_zbmi_who

# model with covariates
fit_with_covariates <- cv.glmnet(x, y, alpha = 1, family = "gaussian")
fit_with_covariates

#model without covariates
x_chemicals_only <- as.matrix(selected_data[, chemicals_full])
fit_without_covariates <- cv.glmnet(x_chemicals_only, y, alpha = 1, family = "gaussian")

# combine chemical data and covariates for the full model
full_data <- cbind(chemical_data_only, covariates_data)
x_full <- as.matrix(full_data)

fit_with_covariates <- cv.glmnet(x_full, y, alpha = 1, family = "gaussian")
x_chemicals_only <- as.matrix(chemical_data_only)
fit_without_covariates <- cv.glmnet(x_chemicals_only, y, alpha = 1, family = "gaussian")

plot(fit_with_covariates)
plot(fit_without_covariates)

cat("Model with Covariates - Lambda Min:", fit_with_covariates$lambda.min, "\n")
cat("Model without Covariates - Lambda Min:", fit_without_covariates$lambda.min, "\n")
```

#### Predicting LASSO

```{r, warning=FALSE}
#LASSO train/test 70-30
set.seed(101)
train_indices <- sample(seq_len(nrow(selected_data)), size = floor(0.7 * nrow(selected_data)))
test_indices <- setdiff(seq_len(nrow(selected_data)), train_indices)

x_train <- as.matrix(selected_data[train_indices, setdiff(names(selected_data), "hs_zbmi_who")])
y_train <- selected_data$hs_zbmi_who[train_indices]

x_test <- as.matrix(selected_data[test_indices, setdiff(names(selected_data), "hs_zbmi_who")])
y_test <- selected_data$hs_zbmi_who[test_indices]

fit_with_covariates_train <- cv.glmnet(x_train, y_train, alpha = 1, family = "gaussian")
fit_with_covariates_test <- predict(fit_with_covariates_train, s = "lambda.min", newx = x_test)
test_mse_with_covariates <- mean((y_test - fit_with_covariates_test)^2)

x_train_chemicals_only <- as.matrix(selected_data[train_indices, chemicals_full])
x_test_chemicals_only <- as.matrix(selected_data[test_indices, chemicals_full])

fit_without_covariates_train <- cv.glmnet(x_train_chemicals_only, y_train, alpha = 1, family = "gaussian")
fit_without_covariates_test <- predict(fit_without_covariates_train, s = "lambda.min", newx = x_test_chemicals_only)
test_mse_without_covariates <- mean((y_test - fit_without_covariates_test)^2)

plot(fit_with_covariates_train, xvar = "lambda", main = "Coefficients Path (With Covariates)")
plot(fit_without_covariates_train, xvar = "lambda", main = "Coefficients Path (Without Covariates)")

best_lambda <- fit_with_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_with_covariates_train, s = best_lambda)  # coefficients at the chosen lambda
best_lambda <- fit_without_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates_train, s = best_lambda)

cat("Model with Covariates - Test MSE:", test_mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", test_mse_without_covariates, "\n")
```

#### Predicting Ridge

```{r, warning=FALSE}
# RIDGE
fit_with_covariates_train <- cv.glmnet(x_train, y_train, alpha = 0, family = "gaussian")
fit_with_covariates_test <- predict(fit_with_covariates_train, s = "lambda.min", newx = x_test)
test_mse_with_covariates <- mean((y_test - fit_with_covariates_test)^2)

x_train_chemicals_only <- as.matrix(selected_data[train_indices, chemicals_full])
x_test_chemicals_only <- as.matrix(selected_data[test_indices, chemicals_full])

fit_without_covariates_train <- cv.glmnet(x_train_chemicals_only, y_train, alpha = 0, family = "gaussian")
fit_without_covariates_test <- predict(fit_without_covariates_train, s = "lambda.min", newx = x_test_chemicals_only)
test_mse_without_covariates <- mean((y_test - fit_without_covariates_test)^2)

plot(fit_with_covariates_train, xvar = "lambda", main = "Coefficients Path (With Covariates)")
plot(fit_without_covariates_train, xvar = "lambda", main = "Coefficients Path (Without Covariates)")

best_lambda <- fit_with_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_with_covariates_train, s = best_lambda)  # coefficients at the chosen lambda
best_lambda <- fit_without_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates_train, s = best_lambda)

cat("Model with Covariates - Test MSE:", test_mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", test_mse_without_covariates, "\n")
```

#### Predicting Elastic Net

```{r, warning=FALSE}
# ELASTIC NET
fit_with_covariates_train <- cv.glmnet(x_train, y_train, alpha = 0.5, family = "gaussian")
fit_with_covariates_test <- predict(fit_with_covariates_train, s = "lambda.min", newx = x_test)
test_mse_with_covariates <- mean((y_test - fit_with_covariates_test)^2)

x_train_chemicals_only <- as.matrix(selected_data[train_indices, chemicals_full])
x_test_chemicals_only <- as.matrix(selected_data[test_indices, chemicals_full])

fit_without_covariates_train <- cv.glmnet(x_train_chemicals_only, y_train, alpha = 0.5, family = "gaussian")
fit_without_covariates_test <- predict(fit_without_covariates_train, s = "lambda.min", newx = x_test_chemicals_only)
test_mse_without_covariates <- mean((y_test - fit_without_covariates_test)^2)

plot(fit_with_covariates_train, xvar = "lambda", main = "Coefficients Path (With Covariates)")
plot(fit_without_covariates_train, xvar = "lambda", main = "Coefficients Path (Without Covariates)")

best_lambda <- fit_with_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_with_covariates_train, s = best_lambda)  # coefficients at the chosen lambda
best_lambda <- fit_without_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates_train, s = best_lambda)

cat("Model with Covariates - Test MSE:", test_mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", test_mse_without_covariates, "\n")
```

### Postnatal Diet Data

```{r, warning=FALSE}
diet_data <- selected_data[, postnatal_diet]

x_diet <- model.matrix(~ . + 0, data = diet_data)  # adding 0 omits the intercept

covariates <- selected_data[, c("e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None")]

x_covariates <- model.matrix(~ . + 0, data = covariates)

x_full <- cbind(x_diet, x_covariates)

# no missing values
x_full[is.na(x_full)] <- 0
x_diet[is.na(x_diet)] <- 0

y <- as.numeric(selected_data$hs_zbmi_who)

# fit model with postnatal diet and with or without covariates
fit_with_covariates <- cv.glmnet(x_full, y, alpha = 1, family = "gaussian")
fit_without_covariates <- cv.glmnet(x_diet, y, alpha = 1, family = "gaussian")

plot(fit_with_covariates)
plot(fit_without_covariates)

cat("Model with Covariates - Lambda Min:", fit_with_covariates$lambda.min, "\n")
cat("Model without Covariates - Lambda Min:", fit_without_covariates$lambda.min, "\n")
```

#### Predicting Lasso

```{r, warning=FALSE}
# LASSO with train/test
set.seed(101)  
train_indices <- sample(seq_len(nrow(selected_data)), size = floor(0.7 * nrow(selected_data)))
test_indices <- setdiff(seq_len(nrow(selected_data)), train_indices)

diet_data <- selected_data[, postnatal_diet]
x_diet_train <- model.matrix(~ . + 0, data = diet_data[train_indices, ])  
x_diet_test <- model.matrix(~ . + 0, data = diet_data[test_indices, ])  

covariates <- selected_data[, c("e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None")]
x_covariates_train <- model.matrix(~ . + 0, data = covariates[train_indices, ]) 
x_covariates_test <- model.matrix(~ . + 0, data = covariates[test_indices, ])

x_full_train <- cbind(x_diet_train, x_covariates_train)
x_full_test <- cbind(x_diet_test, x_covariates_test)

x_full_train[is.na(x_full_train)] <- 0
x_full_test[is.na(x_full_test)] <- 0
x_diet_train[is.na(x_diet_train)] <- 0
x_diet_test[is.na(x_diet_test)] <- 0

y_train <- as.numeric(selected_data$hs_zbmi_who[train_indices])
y_test <- as.numeric(selected_data$hs_zbmi_who[test_indices])

# fit models
fit_with_covariates <- cv.glmnet(x_full_train, y_train, alpha = 1, family = "gaussian")
fit_with_covariates
fit_without_covariates <- cv.glmnet(x_diet_train, y_train, alpha = 1, family = "gaussian")
fit_without_covariates

plot(fit_with_covariates, xvar = "lambda", main = "Coefficient Path (With Covariates)")
plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_with_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_with_covariates, s = best_lambda)  # coefficients at the chosen lambda
best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

predictions_with_covariates <- predict(fit_with_covariates, s = "lambda.min", newx = x_full_test)
mse_with_covariates <- mean((y_test - predictions_with_covariates)^2)

predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_diet_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

cat("Model with Covariates - Test MSE:", mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Predicting Ridge

```{r, warning=FALSE}
# RIDGE
fit_with_covariates <- cv.glmnet(x_full_train, y_train, alpha = 0, family = "gaussian")
fit_with_covariates
fit_without_covariates <- cv.glmnet(x_diet_train, y_train, alpha = 0, family = "gaussian")
fit_without_covariates

plot(fit_with_covariates, xvar = "lambda", main = "Coefficient Path (With Covariates)")
plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_with_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_with_covariates, s = best_lambda)  # coefficients at the chosen lambda
best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

predictions_with_covariates <- predict(fit_with_covariates, s = "lambda.min", newx = x_full_test)
mse_with_covariates <- mean((y_test - predictions_with_covariates)^2)

predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_diet_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

cat("Model with Covariates - Test MSE:", mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Predicting Elastic Net

```{r, warning=FALSE}
#ELASTIC NET
fit_with_covariates <- cv.glmnet(x_full_train, y_train, alpha = 0.5, family = "gaussian")
fit_with_covariates
fit_without_covariates <- cv.glmnet(x_diet_train, y_train, alpha = 0.5, family = "gaussian")
fit_without_covariates

plot(fit_with_covariates, xvar = "lambda", main = "Coefficient Path (With Covariates)")
plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

predictions_with_covariates <- predict(fit_with_covariates, s = "lambda.min", newx = x_full_test)
mse_with_covariates <- mean((y_test - predictions_with_covariates)^2)

predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_diet_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

cat("Model with Covariates - Test MSE:", mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```


### Combined Data (Chemicals & Postnatal Diet)

```{r, warning=FALSE}
x_chemicals <- as.matrix(selected_data[, chemicals_full])
x_diet <- model.matrix(~ . + 0, data = selected_data[, postnatal_diet])

x_covariates <- model.matrix(~ . + 0, data = selected_data[, covariate_names])

# combine all data into one full model matrix withand without covariates
x_full_with_covariates <- cbind(x_chemicals, x_diet, x_covariates)
x_full_without_covariates <- cbind(x_chemicals, x_diet)

# no missing values
x_full_with_covariates[is.na(x_full_with_covariates)] <- 0
x_full_without_covariates[is.na(x_full_without_covariates)] <- 0

y <- as.numeric(selected_data$hs_zbmi_who)

# fit model with and without covariates
fit_with_covariates <- cv.glmnet(x_full_with_covariates, y, alpha = 1, family = "gaussian")
fit_without_covariates <- cv.glmnet(x_full_without_covariates, y, alpha = 1, family = "gaussian")

plot(fit_with_covariates, xvar = "lambda", main = "Coefficients Path (With Covariates)")
plot(fit_without_covariates, xvar = "lambda", main = "Coefficients Path (Without Covariates)")

cat("Model with Covariates - Lambda Min:", fit_with_covariates$lambda.min, "\n")
cat("Model without Covariates - Lambda Min:", fit_without_covariates$lambda.min, "\n")
```

#### Predicting Lasso

```{r, warning=FALSE}
set.seed(101)
train_indices <- sample(seq_len(nrow(selected_data)), size = floor(0.7 * nrow(selected_data)))
test_indices <- setdiff(seq_len(nrow(selected_data)), train_indices)

diet_data <- selected_data[, postnatal_diet]
x_diet_train <- model.matrix(~ . + 0, data = diet_data[train_indices, ])
x_diet_test <- model.matrix(~ . + 0, data = diet_data[test_indices, ])

chemical_data <- selected_data[, chemicals_full]
x_chemical_train <- as.matrix(chemical_data[train_indices, ])
x_chemical_test <- as.matrix(chemical_data[test_indices, ])

covariates <- selected_data[, c("e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None")]
x_covariates_train <- model.matrix(~ . + 0, data = covariates[train_indices, ])
x_covariates_test <- model.matrix(~ . + 0, data = covariates[test_indices, ])

# combine diet and chemical data with and without covariates
x_combined_train <- cbind(x_diet_train, x_chemical_train)
x_combined_test <- cbind(x_diet_test, x_chemical_test)

x_full_train <- cbind(x_combined_train, x_covariates_train)
x_full_test <- cbind(x_combined_test, x_covariates_test)

# make sure no missing values
x_full_train[is.na(x_full_train)] <- 0
x_full_test[is.na(x_full_test)] <- 0
x_combined_train[is.na(x_combined_train)] <- 0
x_combined_test[is.na(x_combined_test)] <- 0

y_train <- as.numeric(selected_data$hs_zbmi_who[train_indices])
y_test <- as.numeric(selected_data$hs_zbmi_who[test_indices])

# LASSO
fit_with_covariates <- cv.glmnet(x_full_train, y_train, alpha = 1, family = "gaussian")
predictions_with_covariates <- predict(fit_with_covariates, s = "lambda.min", newx = x_full_test)
mse_with_covariates <- mean((y_test - predictions_with_covariates)^2)

fit_without_covariates <- cv.glmnet(x_combined_train, y_train, alpha = 1, family = "gaussian")
predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_combined_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

plot(fit_with_covariates, xvar = "lambda", main = "Coefficient Path (With Covariates)")
plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_with_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_with_covariates, s = best_lambda)  # coefficients at the chosen lambda
best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

cat("Model with Covariates - Test MSE:", mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Predicting Ridge

```{r, warning=FALSE}
# RIDGE
fit_with_covariates <- cv.glmnet(x_full_train, y_train, alpha = 0, family = "gaussian")
predictions_with_covariates <- predict(fit_with_covariates, s = "lambda.min", newx = x_full_test)
mse_with_covariates <- mean((y_test - predictions_with_covariates)^2)

fit_without_covariates <- cv.glmnet(x_combined_train, y_train, alpha = 0, family = "gaussian")
predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_combined_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

plot(fit_with_covariates, xvar = "lambda", main = "Coefficient Path (With Covariates)")
plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_with_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_with_covariates, s = best_lambda)  # coefficients at the chosen lambda
best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

cat("Model with Covariates - Test MSE:", mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Predicting Elastic Net

```{r, warning=FALSE}
# ELASTIC NET
fit_with_covariates <- cv.glmnet(x_full_train, y_train, alpha = 0.5, family = "gaussian")
predictions_with_covariates <- predict(fit_with_covariates, s = "lambda.min", newx = x_full_test)
mse_with_covariates <- mean((y_test - predictions_with_covariates)^2)

fit_without_covariates <- cv.glmnet(x_combined_train, y_train, alpha = 0.5, family = "gaussian")
predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_combined_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

plot(fit_with_covariates, xvar = "lambda", main = "Coefficient Path (With Covariates)")
plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_with_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_with_covariates, s = best_lambda)  # coefficients at the chosen lambda
best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

cat("Model with Covariates - Test MSE:", mse_with_covariates, "\n")
cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Group Lasso

```{r, warning=FALSE}
num_chemical_diet <- ncol(x_chemical_train) + ncol(x_diet_train)
num_covariates <- ncol(x_covariates_train)

# make sure these add up to the number of columns in x_full_train
if((num_chemical_diet + num_covariates) != ncol(x_full_train)) {
  cat("Mismatch in expected column counts\n")
}

# define groups
groups <- c(rep(1, num_chemical_diet), rep(2, num_covariates))

# make sure all columns are numeric
x_full_train <- data.frame(x_full_train)
x_full_train[] <- lapply(x_full_train, function(x) {
  if(is.factor(x) || is.character(x)) {
    as.numeric(as.factor(x))
  } else {
    x
  }
})

# to ensure all variables numeric
if(any(sapply(x_full_train, function(x) !is.numeric(x)))) {
  stop("Some columns are still not numeric.")
}

if(length(groups) != ncol(x_full_train)) {
  stop("Group vector length still does not match the number of predictors.")
} else {
  cat("Group vector length now matches the number of predictors.\n")
}

model_group_lasso <- grpreg(x_full_train, y_train, group = groups, penalty = "grLasso")

# x_full_test as numeric
x_full_test <- data.frame(x_full_test)
x_full_test[] <- lapply(x_full_test, function(x) {
  if(is.factor(x) || is.character(x)) {
    as.numeric(as.factor(x))
  } else {
    x
  }
})

if(any(sapply(x_full_test, function(x) !is.numeric(x)))) {
  stop("Some columns in x_full_test are still not numeric.")
}

x_full_test_matrix <- as.matrix(x_full_test)
predictions_group_lasso <- predict(model_group_lasso, x_full_test_matrix, type = "response")

actuals <- y_test
predicted <- predictions_group_lasso
mse <- mean((actuals - predicted)^2)
rmse <- sqrt(mse)
cat("Mean Squared Error:", mse, "\n")
cat("Root Mean Squared Error:", rmse, "\n")
```

#### Clustering

Trying to figure out what to do for :
        * cluster individuals and the individuals would be characterized by having high, medium, or low exposure (discussed last week)

```{r}
set.seed(101)
x_scaled <- scale(x_full_train)  #scale the training data
wss <- sapply(1:15, function(k) {
  kmeans(x_scaled, centers = k, nstart = 20)$tot.withinss
})

plot(1:15, wss, type = "b", pch = 19, frame = FALSE, 
     xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares")

#k-means clustering with the determined number of clusters
k <- which.min(diff(diff(wss))) + 1 
km <- kmeans(x_scaled, centers = k, nstart = 25)

# plot cluster assignment
clusplot(x_scaled, km$cluster, color=TRUE, shade=TRUE, 
         labels=2, lines=0, main=paste("K-means Clustering with", k, "clusters"))
```

#### Random Forest

```{r}
x_full_train[] <- lapply(x_full_train, function(x) if(is.character(x)) factor(x) else x)
x_full_test[] <- lapply(x_full_test, function(x) if(is.character(x)) factor(x) else x)

rf_model <- randomForest(x_full_train, y_train, ntree=500, importance=TRUE)

importance(rf_model)
varImpPlot(rf_model)

# predict on the test set
predictions_rf <- predict(rf_model, x_full_test)

mse_rf <- mean((y_test - predictions_rf)^2)
cat("Random Forest Test MSE:", mse_rf, "\n")
```

#### GBM

```{r}
gbm_model <- gbm(y_train ~ ., data = x_full_train,
                 distribution = "gaussian",
                 n.trees = 1000,
                 interaction.depth = 3,
                 n.minobsinnode = 10,
                 shrinkage = 0.01,
                 cv.folds = 5,
                 verbose = TRUE)

predictions_gbm <- predict(gbm_model, x_full_test, n.trees = 1000, type = "response")

mse_gbm <- mean((y_test - predictions_gbm)^2)

cat("GBM Test MSE:", mse_gbm, "\n")

summary(gbm_model)
```

# Metabolomic Serum Data

First 10 rows and columns of the metabolomic serum data

```{r metabolomic serum data, echo=TRUE}
load("/Users/allison/Library/CloudStorage/GoogleDrive-aflouie@usc.edu/My Drive/HELIX_data/metabol_serum.RData")
kable(metabol_serum.d[1:10,1:10], align="c", digits=2, format="pipe")
```

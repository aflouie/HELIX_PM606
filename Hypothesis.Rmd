---
title: "PM606 Project"
author: "Allison Louie"
date: "2024-06-06"
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
    code_folding: hide
---

```{r setup, include=FALSE}
library(knitr)
library(dplyr)
library(summarytools)
library(kableExtra)
library(tidyverse)
library(Biobase)
library(plotly)
library(profvis)
library(corrplot)
library(table1)
library(tableone)
library(randomForest)
library(caret)
library(nnet)
library(gbm)
library(grpreg)
library(glmnet)
library(cluster)
library(pROC)
library(factoextra)
library(Hmisc)
library(tidyr)
library(grplasso)
options(knitr.table.format = "html")
knitr::opts_chunk$set(echo = TRUE)
work.dir <- here::here()
old.warn <- getOption("warn")
options(warn=-1)
```

# Hypothesis

Postnatal environmental exposures, particularly those found in household products and dietary intake, along with specific serum metabolomics profiles, are significantly associated with the BMI Z-score of children aged 6-11 years. Higher concentrations of certain metabolites in serum, reflecting exposure to chemical classes or metals, will correlate with variations in BMI Z-score, controlling for age and other relevant covariates. Some metabolites associated with chemical exposures and dietary patterns can serve as biomarkers for the risk of developing obesity.

# Background

Research indicates that postnatal exposure to endocrine-disrupting chemicals (EDCs) such as phthalates, bisphenol A (BPA), and polychlorinated biphenyls (PCBs) can significantly influence body weight and metabolic health ([Junge et al., 2018](https://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-018-0478-z)). These chemicals, commonly found in household products and absorbed through dietary intake, are linked to detrimental effects on body weight and metabolic health in children. This hormonal interference can lead to an increased body mass index (BMI) in children, suggesting a potential pathway through which exposure to these chemicals contributes to the development of obesity.

A longitudinal study on Japanese children examined the impact of postnatal exposure (first two years of life) to p,p’*-*dichlorodiphenyltrichloroethane (p,p’*-*DDT) and p,p’*-*dichlorodiphenyldichloroethylene (p,p’*-*DDE) through breastfeeding ([Plouffe et al., 2020](https://ehjournal.biomedcentral.com/articles/10.1186/s12940-020-00603-z)). The findings revealed that higher levels of these chemicals in breast milk were associated with increased BMI at 42 months of age. DDT and DDE may interfere with hormonal pathways related to growth and development. These chemicals can mimic or disrupt hormones that regulate metabolism and fat accumulation. This study highlights the importance of understanding how persistent organic pollutants can affect early childhood growth and development.

The study by [Harley et al. (2013)](https://pubmed.ncbi.nlm.nih.gov/23416456/) investigates the association between prenatal and postnatal Bisphenol A (BPA) exposure and various body composition metrics in children aged 9 years from the CHAMACOS cohort. The study found that higher prenatal BPA exposure was linked to a decrease in BMI and body fat percentages in girls but not boys, suggesting sex-specific effects. Conversely, BPA levels measured at age 9 were positively associated with increased adiposity in both genders, highlighting the different impacts of exposure timing on childhood development.

The 2022 study [2022 study by Uldbjerg et al.](https://academic.oup.com/humupd/article/28/5/687/6573218) explored the effects of combined exposures to multiple EDCs, suggesting that mixtures of these chemicals can have additive or synergistic effects on BMI and obesity risk. Humans are typically exposed to a mixture of chemicals rather than individual EDCs, making it crucial to understand how these mixtures might interact. The research highlighted that the interaction between different EDCs can lead to additive (where the effects simply add up) or even synergistic (where the combined effect is greater than the sum of their separate effects) outcomes. These interactions can significantly amplify the risk factors associated with obesity and metabolic disorders in children. The dose-response relationship found that even low-level exposure to multiple EDCs could result in significant health impacts due to their combined effects.

These studies collectively illustrate the critical role of environmental EDCs in shaping metabolic health outcomes in children, highlighting the necessity for ongoing research and policy intervention to mitigate these risks.

# Data Description

This study will utilize data from the subcohort of 1301 mother-child pairs in the HELIX study, who are which aged 6-11 years for whom complete exposure and outcome data were available. Exposure data included detailed dietary records after pregnancy  and concentrations of various chemicals like BPA and PCBs in child blood samples. There are categorical and numerical variables, which will include both demographic details and biochemical measurements. This dataset allows for robust statistical analysis to identify potential associations between EDC exposure and changes in BMI Z-scores, considering confounding factors such as age, gender, and socioeconomic status. There are no missing data so there is not need to impute the information. Child BMI Z-scores were calculated based on WHO growth standards.

```{r load data and codebook, echo=TRUE}
load("/Users/allison/Library/CloudStorage/GoogleDrive-aflouie@usc.edu/My Drive/HELIX_data/HELIX.RData")
filtered_chem_diet <- codebook %>%
  filter(domain %in% c("Chemicals", "Lifestyles") & period == "Postnatal" & subfamily != "Allergens")

# specific covariates
filtered_covariates <- codebook %>%
  filter(domain == "Covariates" & 
         variable_name %in% c("ID", "e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None"))

#specific phenotype variables
filtered_phenotype <- codebook %>%
  filter(domain == "Phenotype" & 
         variable_name %in% c("hs_zbmi_who"))

# combining all necessary variables together
combined_codebook <- bind_rows(filtered_chem_diet, filtered_covariates, filtered_phenotype)
kable(combined_codebook, align = "c", format = "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

## Data Summary for Exposures, Covariates, and Outcome {.tabset}

### Data Summary Exposures: Lifestyles

```{r Lifestyles summary, attr.output='style="max-height: 100px;"',}
# specific lifestyle exposures
lifestyle_exposures <- c(
  "h_bfdur_Ter",
  "hs_bakery_prod_Ter",
  "hs_break_cer_Ter",
  "hs_dairy_Ter",
  "hs_fastfood_Ter",
  "hs_org_food_Ter",
  "hs_proc_meat_Ter",
  "hs_total_fish_Ter",
  "hs_total_fruits_Ter",
  "hs_total_lipids_Ter",
  "hs_total_sweets_Ter",
  "hs_total_veg_Ter"
)

lifestyle_exposome <- dplyr::select(exposome, all_of(lifestyle_exposures))
summarytools::view(dfSummary(lifestyle_exposome, style = 'grid', plain.ascii = FALSE, valid.col = FALSE, headings = FALSE), method = "render")
```

```{r categorical lifestyle, warning=FALSE}
categorical_lifestyle <- lifestyle_exposome %>% 
  dplyr::select(where(is.factor))

categorical_lifestyle_long <- pivot_longer(
  categorical_lifestyle,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_categorical_vars <- unique(categorical_lifestyle_long$variable)
categorical_plots <- lapply(unique_categorical_vars, function(var) {
  data <- filter(categorical_lifestyle_long, variable == var)
  
  p <- ggplot(data, aes(x = value, fill = value)) +
    geom_bar(stat = "count") +
    labs(title = paste("Distribution of", var), x = var, y = "Count")
  
  print(p)
  return(p)
})
```

Breastfeeding Duration: Majority of observations are in the highest duration category, suggesting longer breastfeeding periods are common.

Bakery Products: Shows a relatively even distribution across the three categories, indicating varied consumption levels of bakery products among participants.

Breakfast Cereal: The highest category of cereal consumption is the most common, suggesting a preference for or greater consumption of cereals.

Dairy: Shows a fairly even distribution across all categories, indicating a uniform consumption pattern of dairy products.

Fast Food: Most participants fall into the middle category, indicating moderate consumption of fast food.

Organic Food: Most participants either consume a lot of or no organic food, with fewer in the middle range.

Processed Meat: Consumption levels are fairly evenly distributed, indicating varied dietary habits regarding processed meats.

Bread: Distribution shows a significant leaning towards higher bread consumption.

Cereal: Even distribution across categories suggests varied cereal consumption habits.

Fish and Seafood: Even distribution across categories, indicating varied consumption of fish and seafood.

Fruits: High fruit consumption is the most common, with fewer participants in the lowest category.

Added Fats: More participants consume added fats at the lowest and highest levels, with fewer in the middle.

Sweets: High consumption of sweets is the most common, indicating a preference for or higher access to sugary foods.

Vegetables: Most participants consume a high amount of vegetables.

### Data Summary Exposures: Chemicals

```{r Chemicals summary, attr.output='style="max-height: 100px;"',}
# specific chemical exposures
chemical_exposures <- c(
  "hs_cd_c_Log2",
  "hs_co_c_Log2",
  "hs_cs_c_Log2",
  "hs_cu_c_Log2",
  "hs_hg_c_Log2",
  "hs_mo_c_Log2",
  "hs_pb_c_Log2",
  "hs_dde_cadj_Log2",
  "hs_pcb153_cadj_Log2",
  "hs_pcb170_cadj_Log2",
  "hs_dep_cadj_Log2",
  "hs_pbde153_cadj_Log2",
  "hs_pfhxs_c_Log2",
  "hs_pfoa_c_Log2",
  "hs_pfos_c_Log2",
  "hs_prpa_cadj_Log2",
  "hs_mbzp_cadj_Log2",
  "hs_mibp_cadj_Log2",
  "hs_mnbp_cadj_Log2"
)

chemical_exposome <- dplyr::select(exposome, all_of(chemical_exposures))
summarytools::view(dfSummary(chemical_exposome, style = 'grid', plain.ascii = FALSE, valid.col = FALSE, headings = FALSE), method = "render")
```

```{r numeric chemicals, warning=FALSE}
#separate numeric and categorical data
numeric_chemical <- chemical_exposome %>% 
  dplyr::select(where(is.numeric))

numeric_chemical_long <- pivot_longer(
  numeric_chemical,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_numerical_vars <- unique(numeric_chemical_long$variable)

num_plots <- lapply(unique_numerical_vars, function(var) {
  data <- filter(numeric_chemical_long, variable == var)
  p <- ggplot(data, aes(x = value)) +
    geom_histogram(bins = 30, fill = "blue") +
    labs(title = paste("Histogram of", var), x = "Value", y = "Count")
  print(p)
  return(p)
})
```

Cadmium (hs_cd_c_Log2): The distribution of cadmium levels is skewed to the right, indicating that most participants have lower exposure levels, with a few cases showing significantly higher exposures.

Cobalt (hs_co_c_Log2): The histogram of cobalt levels displays a roughly normal distribution centered around a slight positive skew. This suggests a common source of exposure with varying levels among the population.

Cesium (hs_cs_c_Log2): Exhibits a right-skewed distribution, indicating that most participants have relatively low exposure levels, but a small number have substantially higher exposures.

Copper (hs_cu_c_Log2): Shows a right-skewed distribution, suggesting that while most individuals have moderate exposure, a few experience significantly higher levels of copper.

Mercury (hs_hg_c_Log2): This distribution is also right-skewed, common for environmental pollutants, where a majority have lower exposure levels, and a minority have high exposure levels.

Molybdenum (hs_mo_c_Log2): Shows a distribution with a sharp peak and a long right tail, suggesting that while most people have similar exposure levels, a few have exceptionally high exposures.

Lead (hs_pb_c_Log2): The distribution is slightly right-skewed, indicating higher exposure levels in a smaller group of the population compared to the majority.

DDE (hs_dde_cadj_Log2): Shows a pronounced right skew, typical for chemicals that accumulate in the environment and in human tissues, indicating higher levels of exposure in a smaller subset of the population..

PCB 153 (hs_pcb153_cadj_Log2): Has a distribution with right skewness, suggesting that exposure to these compounds is higher among a smaller segment of the population.

PCB 170 (hs_pcb170_cadj_Log2): This histograms show a significant right skew, indicating lower concentrations of these chemicals in most samples, with fewer samples showing higher concentrations. This pattern suggests that while most individuals have low exposure, a few may have considerably higher levels.

DEP and PBDE 153: These histograms mostly show multimodal distributions (more than one peak), suggesting different exposure sources or groups within the population that have distinct exposure levels. The multiple peaks could indicate varied exposure pathways or differences in how these chemicals are metabolized or retained in the body.

PFHxS and PFOA: These perfluorinated compounds display a roughly normal distribution skewed right, suggesting a common source of exposure among the population, but with some individuals experiencing higher exposures.

PFOS and PFUnDA: The histograms show a single, sharp peak with a rapid decline, indicating that most individuals have similar exposure levels, likely due to common environmental sources or regulatory controls limiting variability.

MBZP (Monobenzyl Phthalate): This histogram shows a right-skewed distribution. Most values cluster at the lower end, indicating a common lower exposure level among subjects, with a long tail towards higher values suggesting occasional higher exposures.

MECPP (Mono-ethyl hexyl phthalate): The distribution is right-skewed, similar to MBZP, but with a smoother decline. This pattern also indicates that while most subjects have lower exposure levels, a few experience significantly higher exposures.

MEHHP (Mono-2-ethyl-5-hydroxyhexyl phthalate): Exhibits a unimodal distribution with a peak around a middle value and symmetric tails. This could indicate a more standardized exposure level among the subjects with some variation.

MEHP (Mono-ethylhexyl phthalate):Another right-skewed distribution, indicating that most subjects have lower exposure levels but a few have much higher levels.

MEOHP (Mono-2-ethyl-5-oxohexyl phthalate): This histogram shows a distribution with a peak around the middle values and a tail extending towards higher values, suggesting a central tendency with some higher exposures.

MEP (Mono-ethyl phthalate): The distribution is right-skewed, similar to others, showing most subjects with low to moderate levels of exposure, but a few have much higher levels.

```{r chemical corr, warning=FALSE}
numeric_chemical <- select_if(chemical_exposome, is.numeric)
cor_matrix <- cor(numeric_chemical, method = "pearson")
cor_matrix <- cor(numeric_chemical, method = "spearman")
custom_color_scale <- list(
  c(0, "darkred"),    
  c(0.5, "white"), 
  c(1, "darkblue")
)

plot_ly(
  z = cor_matrix, 
  x = colnames(cor_matrix), 
  y = colnames(cor_matrix), 
  type = "heatmap",
  colorscale = custom_color_scale
) %>%
layout(
  title = "Correlation Matrix",
  xaxis = list(tickangle = -90),
  yaxis = list(side = "left")
)
```

### Data Summary Covariates

```{r covariates, warning=FALSE}
# Specified covariates
specific_covariates <- c(
  "e3_sex_None", 
  "e3_yearbir_None", 
  "h_edumc_None", 
  "h_cohort", 
  "hs_child_age_None"
)

covariate_data <- dplyr::select(covariates, all_of(specific_covariates))
summarytools::view(dfSummary(covariate_data, style = 'grid', plain.ascii = FALSE, valid.col = FALSE, headings = FALSE), method = "render")
```

```{r covariates numeric, warning=FALSE}
#separate numeric and categorical data
numeric_covariates <- covariate_data %>% 
  dplyr::select(where(is.numeric))

numeric_covariates_long <- pivot_longer(
  numeric_covariates,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_numerical_vars <- unique(numeric_covariates_long$variable)

num_plots <- lapply(unique_numerical_vars, function(var) {
  data <- filter(numeric_covariates_long, variable == var)
  p <- ggplot(data, aes(x = value)) +
    geom_histogram(bins = 30, fill = "blue") +
    labs(title = paste("Histogram of", var), x = "Value", y = "Count")
  print(p)
  return(p)
})
```

Child's Age (hs_child_age): This histogram is multimodal, reflecting several peaks across different ages. This could be indicative of the data collection points or particular age groups being studied.

```{r covariates categorical, warning=FALSE}
categorical_covariates <- covariate_data %>% 
  dplyr::select(where(is.factor))

categorical_covariates_long <- pivot_longer(
  categorical_covariates,
  cols = everything(),
  names_to = "variable",
  values_to = "value"
)

unique_categorical_vars <- unique(categorical_covariates_long$variable)
categorical_plots <- lapply(unique_categorical_vars, function(var) {
  data <- filter(categorical_covariates_long, variable == var)
  
  p <- ggplot(data, aes(x = value, fill = value)) +
    geom_bar(stat = "count") +
    labs(title = paste("Distribution of", var), x = var, y = "Count")
  
  print(p)
  return(p)
})
```

Cohorts (h_cohort): The distribution shows the count of subjects across six different cohorts. All cohorts have a substantial number of subjects, with cohort 5 showing the highest participation.

Gender Distribution (e3_sex): The gender distribution is nearly balanced with a slight higher count for males compared to females.

Year of Birth (e3_yearbir): This chart shows that the majority of subjects were born in the later years, with a significant increase in 2009, indicating perhaps a larger recruitment or a specific cohort focus that year.

Educational Level (h_educmc): Represents three categories of educational attainment, with category 3 having the highest count, suggesting a higher level of education among the majority of the subjects.

### Data Summary Outcome: Phenotype

```{r phenotype summary}
outcome_BMI <- phenotype %>% 
  dplyr::select(hs_zbmi_who)
summarytools::view(dfSummary(outcome_BMI, style = 'grid', plain.ascii = FALSE, valid.col = FALSE, headings = FALSE), method = "render")
```

```{r combining all data, warning=FALSE}
# Combine all selected data
combined_data <- cbind(covariate_data, lifestyle_exposome, chemical_exposome, outcome_BMI)

# Ensure no duplicated columns
combined_data <- combined_data[, !duplicated(colnames(combined_data))]

# Convert sex variable to a factor for stratification
combined_data$e3_sex_None <- as.factor(combined_data$e3_sex_None)
levels(combined_data$e3_sex_None) <- c("Male", "Female")

render_cont <- function(x) {
  with(stats.default(x), sprintf("%0.2f (%0.2f)", MEAN, SD))
}

render_cat <- function(x) {
  c("", sapply(stats.default(x), function(y) with(y, sprintf("%d (%0.1f %%)", FREQ, PCT))))
}

# Define the formula for table1
table1_formula <- ~ 
  hs_child_age_None + e3_yearbir_None + h_edumc_None + h_cohort +
  hs_zbmi_who +
  h_bfdur_Ter + hs_bakery_prod_Ter + hs_break_cer_Ter + hs_dairy_Ter + hs_fastfood_Ter + hs_org_food_Ter +
  hs_proc_meat_Ter +
  hs_total_fish_Ter + hs_total_fruits_Ter + hs_total_lipids_Ter + hs_total_sweets_Ter + hs_total_veg_Ter +
  hs_cd_c_Log2 + hs_co_c_Log2 + hs_cs_c_Log2 + hs_cu_c_Log2 +
  hs_hg_c_Log2 + hs_mo_c_Log2 + hs_dde_cadj_Log2 + hs_pcb153_cadj_Log2 +
  hs_pcb170_cadj_Log2 + hs_dep_cadj_Log2 + hs_pbde153_cadj_Log2 +
  hs_pfhxs_c_Log2 + hs_pfoa_c_Log2 + hs_pfos_c_Log2 + hs_prpa_cadj_Log2 +
  hs_mbzp_cadj_Log2 + hs_mibp_cadj_Log2 + hs_mnbp_cadj_Log2 | e3_sex_None

# Create the table
table1(
  table1_formula,
  data = combined_data,
  render.continuous = render_cont,
  render.categorical = render_cat,
  overall = TRUE,
  topclass = "Rtable1-shade"
)
```

```{r descriptive table, warning=FALSE}
combined_data$h_cohort <- as.factor(combined_data$h_cohort)
# Create the table
table1(
  ~ hs_child_age_None + e3_sex_None + e3_yearbir_None + h_edumc_None +
    hs_zbmi_who + h_bfdur_Ter + hs_bakery_prod_Ter +
    hs_break_cer_Ter + hs_dairy_Ter + hs_fastfood_Ter +
    hs_org_food_Ter + hs_proc_meat_Ter + hs_total_fish_Ter + hs_total_fruits_Ter +
    hs_total_lipids_Ter +
    hs_total_sweets_Ter + hs_total_veg_Ter +
    hs_cd_c_Log2 + hs_co_c_Log2 + hs_cs_c_Log2 + hs_cu_c_Log2 +
    hs_hg_c_Log2 + hs_mo_c_Log2 + hs_dde_cadj_Log2 + hs_pcb153_cadj_Log2 +
    hs_pcb170_cadj_Log2 + hs_dep_cadj_Log2 + hs_pbde153_cadj_Log2 +
    hs_pfhxs_c_Log2 + hs_pfoa_c_Log2 + hs_pfos_c_Log2 + hs_prpa_cadj_Log2 +
    hs_mbzp_cadj_Log2 + hs_mibp_cadj_Log2 + hs_mnbp_cadj_Log2 | h_cohort,
    data = combined_data,
  render.continuous = render_cont,
  render.categorical = render_cat,
  overall = TRUE,
  topclass = "Rtable1-shade"
)
```

```{r descriptive table 2, warning=FALSE}
combined_data$h_edumc_None <- as.factor(combined_data$h_edumc_None)
table1(
  ~ hs_child_age_None + e3_sex_None + e3_yearbir_None + hs_zbmi_who +
    h_bfdur_Ter + hs_bakery_prod_Ter + hs_break_cer_Ter + hs_dairy_Ter + hs_fastfood_Ter + hs_org_food_Ter +
    hs_proc_meat_Ter +
    hs_total_fish_Ter + hs_total_fruits_Ter + hs_total_lipids_Ter + hs_total_sweets_Ter + 
    hs_total_veg_Ter + hs_cd_c_Log2 + hs_co_c_Log2 + 
    hs_cs_c_Log2 + hs_cu_c_Log2 + hs_hg_c_Log2 + hs_mo_c_Log2 + hs_dde_cadj_Log2 +
    hs_pcb153_cadj_Log2 + hs_pcb170_cadj_Log2 + hs_dep_cadj_Log2 +
    hs_pbde153_cadj_Log2 + hs_pfhxs_c_Log2 + hs_pfoa_c_Log2 + hs_pfos_c_Log2 + 
    hs_prpa_cadj_Log2 + hs_mbzp_cadj_Log2 + hs_mibp_cadj_Log2 + hs_mnbp_cadj_Log2 | h_edumc_None,
  data = combined_data,
  render.continuous = render_cont,
  render.categorical = render_cat,
  overall = TRUE,
  topclass = "Rtable1-shade"
)
```

## All Interested Data

```{r, warning=FALSE}
outcome_cov <- cbind(covariate_data, outcome_BMI)
outcome_cov <- outcome_cov[, !duplicated(colnames(outcome_cov))]
#the full chemicals list
chemicals_full <- c(
  "hs_as_c_Log2",
  "hs_cd_c_Log2",
  "hs_co_c_Log2",
  "hs_cs_c_Log2",
  "hs_cu_c_Log2",
  "hs_hg_c_Log2",
  "hs_mn_c_Log2",
  "hs_mo_c_Log2",
  "hs_pb_c_Log2",
  "hs_tl_cdich_None",
  "hs_dde_cadj_Log2",
  "hs_ddt_cadj_Log2",
  "hs_hcb_cadj_Log2",
  "hs_pcb118_cadj_Log2",
  "hs_pcb138_cadj_Log2",
  "hs_pcb153_cadj_Log2",
  "hs_pcb170_cadj_Log2",
  "hs_pcb180_cadj_Log2",
  "hs_dep_cadj_Log2",
  "hs_detp_cadj_Log2",
  "hs_dmdtp_cdich_None",
  "hs_dmp_cadj_Log2",
  "hs_dmtp_cadj_Log2",
  "hs_pbde153_cadj_Log2",
  "hs_pbde47_cadj_Log2",
  "hs_pfhxs_c_Log2",
  "hs_pfna_c_Log2",
  "hs_pfoa_c_Log2",
  "hs_pfos_c_Log2",
  "hs_pfunda_c_Log2",
  "hs_bpa_cadj_Log2",
  "hs_bupa_cadj_Log2",
  "hs_etpa_cadj_Log2",
  "hs_mepa_cadj_Log2",
  "hs_oxbe_cadj_Log2",
  "hs_prpa_cadj_Log2",
  "hs_trcs_cadj_Log2",
  "hs_mbzp_cadj_Log2",
  "hs_mecpp_cadj_Log2",
  "hs_mehhp_cadj_Log2",
  "hs_mehp_cadj_Log2",
  "hs_meohp_cadj_Log2",
  "hs_mep_cadj_Log2",
  "hs_mibp_cadj_Log2",
  "hs_mnbp_cadj_Log2",
  "hs_ohminp_cadj_Log2",
  "hs_oxominp_cadj_Log2",
  "hs_cotinine_cdich_None",
  "hs_globalexp2_None"
)

#postnatal diet for child
postnatal_diet <- c(
  "h_bfdur_Ter",
  "hs_bakery_prod_Ter",
  "hs_beverages_Ter",
  "hs_break_cer_Ter",
  "hs_caff_drink_Ter",
  "hs_dairy_Ter",
  "hs_fastfood_Ter",
  "hs_org_food_Ter",
  "hs_proc_meat_Ter",
  "hs_readymade_Ter",
  "hs_total_bread_Ter",
  "hs_total_cereal_Ter",
  "hs_total_fish_Ter",
  "hs_total_fruits_Ter",
  "hs_total_lipids_Ter",
  "hs_total_meat_Ter",
  "hs_total_potatoes_Ter",
  "hs_total_sweets_Ter",
  "hs_total_veg_Ter",
  "hs_total_yog_Ter"
)

chemicals_columns <- c(chemicals_full)
all_chemicals <- exposome %>% dplyr::select(all_of(chemicals_columns))

diet_columns <- c(postnatal_diet)
all_diet <- exposome %>% dplyr::select(all_of(diet_columns))

all_columns <- c(chemicals_full, postnatal_diet)
extracted_exposome <- exposome %>% dplyr::select(all_of(all_columns))

chemicals_outcome_cov <- cbind(outcome_cov, all_chemicals)

diet_outcome_cov <- cbind(outcome_cov, all_diet)

interested_data <- cbind(outcome_cov, extracted_exposome)
head(interested_data)
```

```{r, warning=FALSE}
interested_data_corr <- select_if(interested_data, is.numeric)
cor_matrix <- cor(interested_data_corr, method = "pearson")
cor_matrix <- cor(interested_data_corr, method = "spearman")
custom_color_scale <- list(
  c(0, "darkred"),    
  c(0.5, "white"), 
  c(1, "darkblue")
)

plot_ly(
  z = cor_matrix, 
  x = colnames(cor_matrix), 
  y = colnames(cor_matrix), 
  type = "heatmap",
  colorscale = custom_color_scale
) %>%
layout(
  title = "Correlation Matrix",
  xaxis = list(tickangle = -90),
  yaxis = list(side = "left")
)
```

## Comparing Models with and without Covariates

### Chemicals Data

#### Predicting LASSO

```{r, warning=FALSE}
#LASSO train/test 70-30
set.seed(101)
train_indices <- sample(seq_len(nrow(chemicals_outcome_cov)), size = floor(0.7 * nrow(interested_data)))
test_indices <- setdiff(seq_len(nrow(chemicals_outcome_cov)), train_indices)

x_train <- as.matrix(chemicals_outcome_cov[train_indices, setdiff(names(chemicals_outcome_cov), "hs_zbmi_who")])
y_train <- chemicals_outcome_cov$hs_zbmi_who[train_indices]

x_test <- as.matrix(chemicals_outcome_cov[test_indices, setdiff(names(chemicals_outcome_cov), "hs_zbmi_who")])
y_test <- chemicals_outcome_cov$hs_zbmi_who[test_indices]

x_train_chemicals_only <- as.matrix(chemicals_outcome_cov[train_indices, chemicals_full])
x_test_chemicals_only <- as.matrix(chemicals_outcome_cov[test_indices, chemicals_full])

fit_without_covariates_train <- cv.glmnet(x_train_chemicals_only, y_train, alpha = 1, family = "gaussian")
fit_without_covariates_test <- predict(fit_without_covariates_train, s = "lambda.min", newx = x_test_chemicals_only)
test_mse_without_covariates <- mean((y_test - fit_without_covariates_test)^2)

plot(fit_without_covariates_train, xvar = "lambda", main = "Coefficients Path (Without Covariates)")

best_lambda <- fit_without_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates_train, s = best_lambda)

cat("Model without Covariates - Test MSE:", test_mse_without_covariates, "\n")
```

#### Predicting Ridge

```{r, warning=FALSE}
# RIDGE
fit_without_covariates_train <- cv.glmnet(x_train_chemicals_only, y_train, alpha = 0, family = "gaussian")
fit_without_covariates_test <- predict(fit_without_covariates_train, s = "lambda.min", newx = x_test_chemicals_only)
test_mse_without_covariates <- mean((y_test - fit_without_covariates_test)^2)

plot(fit_without_covariates_train, xvar = "lambda", main = "Coefficients Path (Without Covariates)")

best_lambda <- fit_without_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates_train, s = best_lambda)

cat("Model without Covariates - Test MSE:", test_mse_without_covariates, "\n")
```

#### Predicting Elastic Net

```{r, warning=FALSE}
# ELASTIC NET
fit_without_covariates_train <- cv.glmnet(x_train_chemicals_only, y_train, alpha = 0.5, family = "gaussian")
fit_without_covariates_test <- predict(fit_without_covariates_train, s = "lambda.min", newx = x_test_chemicals_only)
test_mse_without_covariates <- mean((y_test - fit_without_covariates_test)^2)

plot(fit_without_covariates_train, xvar = "lambda", main = "Coefficients Path (Without Covariates)")

best_lambda <- fit_without_covariates_train$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates_train, s = best_lambda)

cat("Model without Covariates - Test MSE:", test_mse_without_covariates, "\n")
```

### Postnatal Diet Data

#### Predicting Lasso

```{r, warning=FALSE}
# LASSO with train/test
set.seed(101)  
train_indices <- sample(seq_len(nrow(diet_outcome_cov)), size = floor(0.7 * nrow(diet_outcome_cov)))
test_indices <- setdiff(seq_len(nrow(diet_outcome_cov)), train_indices)

diet_data <- diet_outcome_cov[, postnatal_diet]
x_diet_train <- model.matrix(~ . + 0, data = diet_data[train_indices, ])  
x_diet_test <- model.matrix(~ . + 0, data = diet_data[test_indices, ])  

covariates <- diet_outcome_cov[, c("e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None")]
x_covariates_train <- model.matrix(~ . + 0, data = covariates[train_indices, ]) 
x_covariates_test <- model.matrix(~ . + 0, data = covariates[test_indices, ])

x_full_train <- cbind(x_diet_train, x_covariates_train)
x_full_test <- cbind(x_diet_test, x_covariates_test)

x_full_train[is.na(x_full_train)] <- 0
x_full_test[is.na(x_full_test)] <- 0
x_diet_train[is.na(x_diet_train)] <- 0
x_diet_test[is.na(x_diet_test)] <- 0

y_train <- as.numeric(diet_outcome_cov$hs_zbmi_who[train_indices])
y_test <- as.numeric(diet_outcome_cov$hs_zbmi_who[test_indices])

# fit models
fit_without_covariates <- cv.glmnet(x_diet_train, y_train, alpha = 1, family = "gaussian")
fit_without_covariates

plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_diet_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Predicting Ridge

```{r, warning=FALSE}
# RIDGE
fit_without_covariates <- cv.glmnet(x_diet_train, y_train, alpha = 0, family = "gaussian")
fit_without_covariates

plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_diet_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Predicting Elastic Net

```{r, warning=FALSE}
#ELASTIC NET
fit_without_covariates <- cv.glmnet(x_diet_train, y_train, alpha = 0.5, family = "gaussian")
fit_without_covariates

plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_diet_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

### Combined Data (Chemicals & Postnatal Diet)

#### Predicting Lasso

```{r, warning=FALSE}
set.seed(101)
train_indices <- sample(seq_len(nrow(interested_data)), size = floor(0.7 * nrow(interested_data)))
test_indices <- setdiff(seq_len(nrow(interested_data)), train_indices)

diet_data <- interested_data[, postnatal_diet]
x_diet_train <- model.matrix(~ . + 0, data = diet_data[train_indices, ])
x_diet_test <- model.matrix(~ . + 0, data = diet_data[test_indices, ])

chemical_data <- interested_data[, chemicals_full]
x_chemical_train <- as.matrix(chemical_data[train_indices, ])
x_chemical_test <- as.matrix(chemical_data[test_indices, ])

covariates <- interested_data[, c("e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None")]
x_covariates_train <- model.matrix(~ . + 0, data = covariates[train_indices, ])
x_covariates_test <- model.matrix(~ . + 0, data = covariates[test_indices, ])

# combine diet and chemical data with and without covariates
x_combined_train <- cbind(x_diet_train, x_chemical_train)
x_combined_test <- cbind(x_diet_test, x_chemical_test)

x_full_train <- cbind(x_combined_train, x_covariates_train)
x_full_test <- cbind(x_combined_test, x_covariates_test)

# make sure no missing values
x_full_train[is.na(x_full_train)] <- 0
x_full_test[is.na(x_full_test)] <- 0
x_combined_train[is.na(x_combined_train)] <- 0
x_combined_test[is.na(x_combined_test)] <- 0

y_train <- as.numeric(interested_data$hs_zbmi_who[train_indices])
y_test <- as.numeric(interested_data$hs_zbmi_who[test_indices])

# LASSO
fit_without_covariates <- cv.glmnet(x_combined_train, y_train, alpha = 1, family = "gaussian")
predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_combined_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Predicting Ridge

```{r, warning=FALSE}
# RIDGE
fit_without_covariates <- cv.glmnet(x_combined_train, y_train, alpha = 0, family = "gaussian")
predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_combined_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

#### Predicting Elastic Net

```{r, warning=FALSE}
# ELASTIC NET
fit_without_covariates <- cv.glmnet(x_combined_train, y_train, alpha = 0.5, family = "gaussian")
predictions_without_covariates <- predict(fit_without_covariates, s = "lambda.min", newx = x_combined_test)
mse_without_covariates <- mean((y_test - predictions_without_covariates)^2)

plot(fit_without_covariates, xvar = "lambda", main = "Coefficient Path (Without Covariates)")

best_lambda <- fit_without_covariates$lambda.min  # lambda that minimizes the MSE
coef(fit_without_covariates, s = best_lambda)

cat("Model without Covariates - Test MSE:", mse_without_covariates, "\n")
```

# Finalized Data

Selected data based on the enet features without covariates.

Still trying to decide if to stick with continuous or dichotomous outcome (for sensitivity/specificity).  Will try to freeze the covariates in the lasso, ridge, or enet.

```{r selected chemicals, warning=FALSE}
#selected chemicals that were noted in enet
chemicals_selected <- c(
  "hs_cd_c_Log2",
  "hs_co_c_Log2",
  "hs_cs_c_Log2",
  "hs_cu_c_Log2",
  "hs_hg_c_Log2",
  "hs_mo_c_Log2",
  "hs_pb_c_Log2",
  "hs_dde_cadj_Log2",
  "hs_pcb153_cadj_Log2",
  "hs_pcb170_cadj_Log2",
  "hs_dep_cadj_Log2",
  "hs_detp_cadj_Log2",
  "hs_pbde153_cadj_Log2",
  "hs_pfhxs_c_Log2",
  "hs_pfoa_c_Log2",
  "hs_pfos_c_Log2",
  "hs_mepa_cadj_Log2",
  "hs_oxbe_cadj_Log2",
  "hs_prpa_cadj_Log2",
  "hs_mbzp_cadj_Log2",
  "hs_mibp_cadj_Log2",
  "hs_mnbp_cadj_Log2")
```

```{r selected diet, warning=FALSE}
#selected diets that were noted in enet
diet_selected <- c(
  "h_bfdur_Ter",
  "hs_bakery_prod_Ter",
  "hs_break_cer_Ter",
  "hs_dairy_Ter",
  "hs_fastfood_Ter",
  "hs_org_food_Ter",
  "hs_proc_meat_Ter",
  "hs_total_fish_Ter",
  "hs_total_fruits_Ter",
  "hs_total_lipids_Ter",
  "hs_total_sweets_Ter",
  "hs_total_veg_Ter"
)
```

```{r final data, warning=FALSE}
combined_data_selected <- c(
  "h_bfdur_Ter",
  "hs_bakery_prod_Ter",
  "hs_dairy_Ter",
  "hs_fastfood_Ter",
  "hs_org_food_Ter",
  "hs_readymade_Ter",
  "hs_total_bread_Ter",
  "hs_total_fish_Ter",
  "hs_total_fruits_Ter",
  "hs_total_lipids_Ter",
  "hs_total_potatoes_Ter",
  "hs_total_sweets_Ter",
  "hs_total_veg_Ter",
  "hs_cd_c_Log2",
  "hs_co_c_Log2",
  "hs_cs_c_Log2",
  "hs_cu_c_Log2",
  "hs_hg_c_Log2",
  "hs_mo_c_Log2",
  "hs_pb_c_Log2",
  "hs_dde_cadj_Log2",
  "hs_pcb153_cadj_Log2",
  "hs_pcb170_cadj_Log2",
  "hs_dep_cadj_Log2",
  "hs_pbde153_cadj_Log2",
  "hs_pfhxs_c_Log2",
  "hs_pfoa_c_Log2",
  "hs_pfos_c_Log2",
  "hs_prpa_cadj_Log2",
  "hs_mbzp_cadj_Log2",
  "hs_mibp_cadj_Log2",
  "hs_mnbp_cadj_Log2"
)

outcome_cov <- cbind(covariate_data, outcome_BMI)
outcome_cov <- outcome_cov[, !duplicated(colnames(outcome_cov))]

finalized_columns <- c(combined_data_selected)
final_selected_data <- exposome %>% dplyr::select(all_of(finalized_columns))

finalized_data <- cbind(outcome_cov, final_selected_data)
head(finalized_data)
```

```{r corr plot, warning = FALSE}
numeric_vars <- finalized_data %>%
  dplyr::select(where(is.numeric))

cor_matrix <- cor(numeric_vars, use = "complete.obs")
corrplot(cor_matrix, method = "color", type = "upper", tl.col = "black", tl.srt = 60, tl.cex = 0.8)
```

```{r train-test, warning=FALSE}
set.seed(101)

# Splitting data into training and test sets
train_indices <- sample(seq_len(nrow(finalized_data)), size = floor(0.7 * nrow(finalized_data)))
test_indices <- setdiff(seq_len(nrow(finalized_data)), train_indices)

# Creating training and test datasets
train_data <- finalized_data[train_indices, ]
test_data <- finalized_data[test_indices, ]

# Separating predictors and outcome variable
x_train <- model.matrix(~ . + 0, data = train_data[ , !names(train_data) %in% "hs_zbmi_who"])
x_test <- model.matrix(~ . + 0, data = test_data[ , !names(test_data) %in% "hs_zbmi_who"])
y_train <- train_data$hs_zbmi_who
y_test <- test_data$hs_zbmi_who
```

## LASSO

```{r lasso fit, warning = FALSE}
fit_lasso <- cv.glmnet(x_train, y_train, alpha = 1, family = "gaussian")
plot(fit_lasso, xvar = "lambda", main = "Coefficients Path")
best_lambda <- fit_lasso$lambda.min
coef(fit_lasso, s = best_lambda)

predictions_lasso <- predict(fit_lasso, s = "lambda.min", newx = x_test)
mse_lasso <- mean((y_test - predictions_lasso)^2)
rmse_lasso <- sqrt(mse_lasso)

roc_lasso <- roc(y_test, predictions_lasso)
auc_lasso <- auc(roc_lasso)

cat("Lasso Test MSE:", mse_lasso, "\n")
cat("Lasso Test RMSE:", rmse_lasso, "\n")
cat("Lasso Test AUC:", auc_lasso)
plot(roc_lasso, main = "ROC Curve (Lasso)")
```

## Ridge

```{r ridge fit, warning=FALSE}
fit_ridge <- cv.glmnet(x_train, y_train, alpha = 0, family = "gaussian")
plot(fit_ridge, xvar = "lambda", main = "Coefficients Path")
best_lambda <- fit_ridge$lambda.min
coef(fit_ridge, s = best_lambda)

predictions_ridge <- predict(fit_ridge, s = "lambda.min", newx = x_test)
mse_ridge <- mean((y_test - predictions_ridge)^2)
rmse_ridge <- sqrt(mse_ridge)

roc_ridge <- roc(y_test, predictions_ridge)
auc_ridge <- auc(roc_ridge)

cat("Ridge Test MSE:", mse_ridge, "\n")
cat("Ridge Test RMSE:", rmse_ridge, "\n")
cat("Ridge Test AUC:", auc_ridge, "\n")
plot(roc_ridge, main = "ROC Curve (Ridge)")
```

## Elastic Net

```{r enet fit, warning = FALSE}
fit_enet <- cv.glmnet(x_train, y_train, alpha = 0.5, family = "gaussian")
plot(fit_enet, xvar = "lambda", main = "Coefficients Path")
best_lambda <- fit_enet$lambda.min
coef(fit_enet, s = best_lambda)
predictions_enet <- predict(fit_enet, s = "lambda.min", newx = x_test)
mse_enet <- mean((y_test - predictions_enet)^2)
rmse_enet <- sqrt(mse_enet)

roc_enet <- roc(y_test, predictions_enet)
auc_enet <- auc(roc_enet)

cat("Elastic Net Test MSE:", mse_enet, "\n")
cat("Elastic Net Test RMSE:", rmse_enet, "\n")
cat("Elastic Net Test AUC:", auc_enet, "\n")
plot(roc_enet, main = "ROC Curve (Elastic Net)")
```

## Random Forest

```{r rf fit, warning=FALSE}
rf_model <- randomForest(x_train, y_train, ntree=500, importance=TRUE)
predictions_rf <- predict(rf_model, x_test)
mse_rf <- mean((y_test - predictions_rf)^2)
rmse_rf <- sqrt(mse_rf)

roc_rf <- roc(y_test, predictions_rf)
auc_rf <- auc(roc_rf)

cat("Random Forest Test MSE:", mse_rf, "\n")
cat("Random Forest Test RMSE:", rmse_rf, "\n")
cat("Random Forest Test AUC:", auc_rf, "\n")
plot(roc_rf, main = "ROC Curve (Random Forest)")
varImpPlot(rf_model)
```

## GBM

```{r gbm fit, warning = FALSE}
gbm_model <- gbm(hs_zbmi_who ~ ., data = train_data, 
                 distribution = "gaussian",
                 n.trees = 1000,
                 interaction.depth = 3,
                 n.minobsinnode = 10,
                 shrinkage = 0.01,
                 cv.folds = 5,
                 verbose = TRUE)

# finding the best number of trees based on cross-validation
best_trees <- gbm.perf(gbm_model, method = "cv")
predictions_gbm <- predict(gbm_model, test_data, n.trees = best_trees)
mse_gbm <- mean((y_test - predictions_gbm)^2)
rmse_gbm <- sqrt(mse_gbm)

roc_gbm <- roc(y_test, predictions_gbm)
auc_gbm <- auc(roc_gbm)

cat("GBM Test MSE:", mse_gbm, "\n")
cat("GBM Test RMSE:", rmse_gbm, "\n")
cat("GBM Test AUC:", auc_gbm, "\n")
plot(roc_gbm, main = "ROC Curve (GBM)")
summary(gbm_model)
```

## Cross-Validation

```{r cv of all models, warning=FALSE}
profvis({
  control <- trainControl(method = "cv", number = 5)

  # lasso with cross-validation
  fit_lasso_cv <- train(x_train, y_train, method = "glmnet", 
                        trControl = control, tuneGrid = expand.grid(alpha = 1, lambda = fit_lasso$lambda.min))
  print(fit_lasso_cv)
  
  # ridge with cross-validation
  fit_ridge_cv <- train(x_train, y_train, method = "glmnet", 
                        trControl = control, tuneGrid = expand.grid(alpha = 0, lambda = fit_ridge$lambda.min))
  print(fit_ridge_cv)
  
  # enet with cross-validation
  fit_enet_cv <- train(x_train, y_train, method = "glmnet", 
                       trControl = control, tuneGrid = expand.grid(alpha = 0.5, lambda = fit_enet$lambda.min))
  print(fit_enet_cv)
  
  # random forest with cross-validation
  rf_cv <- train(x_train, y_train, method = "rf", trControl = control)
  print(rf_cv)
  
  # GBM with cross-validation
  gbm_cv <- train(hs_zbmi_who ~ ., data = train_data, method = "gbm", trControl = control, verbose = FALSE)
  print(gbm_cv)
})
```

# With Metabolomic Serum Data

First 10 rows and columns of the metabolomic serum data

```{r metabolomic serum data, echo=TRUE}
load("/Users/allison/Library/CloudStorage/GoogleDrive-aflouie@usc.edu/My Drive/HELIX_data/metabol_serum.RData")
kable(metabol_serum.d[1:10,1:10], align="c", digits=2, format="pipe")
```

```{r transposed serum data, warning = FALSE}
metabol_serum_transposed <- as.data.frame(t(metabol_serum.d))
metabol_serum_transposed$ID <- as.integer(rownames(metabol_serum_transposed))

# Add the ID column to the first position
metabol_serum_transposed <- metabol_serum_transposed[, c("ID", setdiff(names(metabol_serum_transposed), "ID"))]

# Now, the ID is the first column, and the layout is preserved
kable(head(metabol_serum_transposed), align = "c", digits = 2, format = "pipe")
```

```{r adding ID to combine metabolics, include=FALSE}
# specific covariates
load("/Users/allison/Library/CloudStorage/GoogleDrive-aflouie@usc.edu/My Drive/HELIX_data/HELIX.RData")
filtered_chem_diet <- codebook %>%
  filter(domain %in% c("Chemicals", "Lifestyles") & period == "Postnatal" & subfamily != "Allergens")

# specific covariates
filtered_covariates <- codebook %>%
  filter(domain == "Covariates" & 
         variable_name %in% c("ID", "e3_sex_None", "e3_yearbir_None", "h_edumc_None", "h_cohort", "hs_child_age_None"))

#specific phenotype variables
filtered_phenotype <- codebook %>%
  filter(domain == "Phenotype" & 
         variable_name %in% c("hs_zbmi_who"))

# combining all necessary variables together
combined_codebook <- bind_rows(filtered_chem_diet, filtered_covariates, filtered_phenotype)

outcome_and_cov <- cbind(covariates, outcome_BMI)
outcome_and_cov <- outcome_and_cov[, !duplicated(colnames(outcome_and_cov))]
outcome_and_cov <- outcome_and_cov %>%
  dplyr::select(ID, hs_child_age_None, h_cohort, e3_sex_None, e3_yearbir_None, h_edumc_None, h_native_None, hs_zbmi_who)
#the full chemicals list
chemicals_specific <- c(
  "hs_cd_c_Log2",
  "hs_co_c_Log2",
  "hs_cs_c_Log2",
  "hs_cu_c_Log2",
  "hs_hg_c_Log2",
  "hs_mo_c_Log2",
  "hs_pb_c_Log2",
  "hs_dde_cadj_Log2",
  "hs_pcb153_cadj_Log2",
  "hs_pcb170_cadj_Log2",
  "hs_dep_cadj_Log2",
  "hs_pbde153_cadj_Log2",
  "hs_pfhxs_c_Log2",
  "hs_pfoa_c_Log2",
  "hs_pfos_c_Log2",
  "hs_prpa_cadj_Log2",
  "hs_mbzp_cadj_Log2",
  "hs_mibp_cadj_Log2",
  "hs_mnbp_cadj_Log2"
)

#postnatal diet for child
postnatal_diet <- c(
  "h_bfdur_Ter",
  "hs_bakery_prod_Ter",
  "hs_dairy_Ter",
  "hs_fastfood_Ter",
  "hs_org_food_Ter",
  "hs_readymade_Ter",
  "hs_total_bread_Ter",
  "hs_total_fish_Ter",
  "hs_total_fruits_Ter",
  "hs_total_lipids_Ter",
  "hs_total_potatoes_Ter",
  "hs_total_sweets_Ter",
  "hs_total_veg_Ter"
)

all_columns <- c(chemicals_specific, postnatal_diet)
extracted_exposome <- exposome %>% dplyr::select(all_of(all_columns))

selected_id_data <- cbind(outcome_and_cov, extracted_exposome)

# ID is the common identifier in both datasets
combined_data <- merge(selected_id_data, metabol_serum_transposed, by = "ID", all = TRUE)
head(combined_data)

selected_metabolomics_data <- combined_data %>% dplyr::select(-c(ID))
```

## LASSO

```{r lasso predictions, warning=FALSE}
#removing any NA, might be problematic but hard to impute completely
selected_metabolomics_data <- selected_metabolomics_data %>% na.omit()

set.seed(101)
trainIndex <- createDataPartition(selected_metabolomics_data$hs_zbmi_who, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- selected_metabolomics_data[ trainIndex,]
test_data  <- selected_metabolomics_data[-trainIndex,]

x_train <- model.matrix(hs_zbmi_who ~ ., train_data)[,-1]
y_train <- train_data$hs_zbmi_who
x_test <- model.matrix(hs_zbmi_who ~ ., test_data)[,-1]
y_test <- test_data$hs_zbmi_who

lasso_model <- cv.glmnet(x_train, y_train, alpha = 1, family = "gaussian")
plot(lasso_model)
lasso_model$lambda.min
coef(lasso_model, s = lasso_model$lambda.min)
lasso_predictions <- predict(lasso_model, s = lasso_model$lambda.min, newx = x_test)

test_mse <- mean((lasso_predictions - y_test)^2)
cat("Mean Squared Error on Test Set:", test_mse, "\n")
```

```{r lasso sensitivity-specificity}
# convert hs_zbmi_who to binary based on median
median_value <- median(selected_metabolomics_data$hs_zbmi_who, na.rm = TRUE)
selected_metabolomics_data$hs_zbmi_who_binary <- ifelse(selected_metabolomics_data$hs_zbmi_who > median_value, 1, 0)

set.seed(101)
trainIndex <- createDataPartition(selected_metabolomics_data$hs_zbmi_who_binary, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- selected_metabolomics_data[trainIndex,]
test_data  <- selected_metabolomics_data[-trainIndex,]

x_train <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, train_data)[,-1]
y_train <- train_data$hs_zbmi_who_binary
x_test <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, test_data)[,-1]
y_test <- test_data$hs_zbmi_who_binary

# fit LASSO model using cross-validation
lasso_model <- cv.glmnet(x_train, y_train, alpha = 1, family = "binomial")
plot(lasso_model)

best_lambda <- lasso_model$lambda.min
cat("Best Lambda:", best_lambda, "\n")

# Get coefficients at best lambda
coef(lasso_model, s = best_lambda)

lasso_predictions <- predict(lasso_model, s = best_lambda, newx = x_test, type = "response")

# convert probabilities to binary predictions
binary_predictions <- ifelse(lasso_predictions > 0.5, 1, 0)

# make sure levels match between binary_predictions and y_test
binary_predictions <- factor(binary_predictions, levels = c(0, 1))
y_test <- factor(y_test, levels = c(0, 1))

# evaluate accuracy
accuracy <- mean(binary_predictions == y_test)
cat("LASSO Accuracy on Test Set:", accuracy, "\n")

conf_matrix <- confusionMatrix(binary_predictions, y_test)
conf_matrix

# ROC Curve and AUC
roc_curve <- roc(as.numeric(y_test), as.numeric(lasso_predictions))
plot(roc_curve, main = "ROC Curve for LASSO Model")
auc_value <- auc(roc_curve)
cat("LASSO AUC on Test Set:", auc_value, "\n")
```

## Ridge

```{r ridge predictions}
set.seed(101)
trainIndex <- createDataPartition(selected_metabolomics_data$hs_zbmi_who, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- selected_metabolomics_data[ trainIndex,]
test_data  <- selected_metabolomics_data[-trainIndex,]

x_train <- model.matrix(hs_zbmi_who ~ . - hs_zbmi_who_binary, train_data)[,-1]
y_train <- train_data$hs_zbmi_who
x_test <- model.matrix(hs_zbmi_who ~ . - hs_zbmi_who_binary, test_data)[,-1]
y_test <- test_data$hs_zbmi_who

ridge_model <- cv.glmnet(x_train, y_train, alpha = 0, family = "gaussian")
plot(ridge_model)
ridge_model$lambda.min
coef(ridge_model, s = ridge_model$lambda.min)
predictions <- predict(ridge_model, s = ridge_model$lambda.min, newx = x_test)

test_mse <- mean((predictions - y_test)^2)
cat("Mean Squared Error on Test Set:", test_mse, "\n")
```

```{r ridge sensitivity-specificity, warning = FALSE}
# convert hs_zbmi_who to binary based on median
median_value <- median(selected_metabolomics_data$hs_zbmi_who, na.rm = TRUE)
selected_metabolomics_data$hs_zbmi_who_binary <- ifelse(selected_metabolomics_data$hs_zbmi_who > median_value, 1, 0)

set.seed(101)
trainIndex <- createDataPartition(selected_metabolomics_data$hs_zbmi_who_binary, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- selected_metabolomics_data[trainIndex,]
test_data  <- selected_metabolomics_data[-trainIndex,]

x_train <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, train_data)[,-1]
y_train <- train_data$hs_zbmi_who_binary
x_test <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, test_data)[,-1]
y_test <- test_data$hs_zbmi_who_binary

# fit ridge model using cross-validation
ridge_model <- cv.glmnet(x_train, y_train, alpha = 0, family = "binomial")
plot(ridge_model)

best_lambda <- ridge_model$lambda.min
cat("Best Lambda:", best_lambda, "\n")

coef(ridge_model, s = best_lambda)

ridge_predictions <- predict(ridge_model, s = best_lambda, newx = x_test, type = "response")

# convert probabilities to binary predictions
binary_predictions <- ifelse(ridge_predictions > 0.5, 1, 0)

# make sure levels match between binary_predictions and y_test
binary_predictions <- factor(binary_predictions, levels = c(0, 1))
y_test <- factor(y_test, levels = c(0, 1))

# accuracy accuracy
accuracy <- mean(binary_predictions == y_test)
cat("Ridge Accuracy on Test Set:", accuracy, "\n")

conf_matrix <- confusionMatrix(binary_predictions, y_test)
conf_matrix

# ROC Curve and AUC
roc_curve <- roc(as.numeric(y_test), as.numeric(ridge_predictions))
plot(roc_curve, main = "ROC Curve for Ridge Model")
auc_value <- auc(roc_curve)
cat("Ridge AUC on Test Set:", auc_value, "\n")
```

## Elastic

```{r elastic predictions}
set.seed(101)
trainIndex <- createDataPartition(selected_metabolomics_data$hs_zbmi_who, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- selected_metabolomics_data[ trainIndex,]
test_data  <- selected_metabolomics_data[-trainIndex,]

x_train <- model.matrix(hs_zbmi_who ~ . - hs_zbmi_who_binary, train_data)[,-1]
y_train <- train_data$hs_zbmi_who
x_test <- model.matrix(hs_zbmi_who ~ . - hs_zbmi_who_binary, test_data)[,-1]
y_test <- test_data$hs_zbmi_who

enet_model <- cv.glmnet(x_train, y_train, alpha = 0.5, family = "gaussian")
plot(enet_model)
enet_model$lambda.min
coef(enet_model, s = enet_model$lambda.min)
predictions <- predict(enet_model, s = enet_model$lambda.min, newx = x_test)

test_mse <- mean((predictions - y_test)^2)
cat("Mean Squared Error on Test Set:", test_mse, "\n")
```

```{r enet sensitivity-specificity, warning = FALSE}
# convert hs_zbmi_who to binary based on median
median_value <- median(selected_metabolomics_data$hs_zbmi_who, na.rm = TRUE)
selected_metabolomics_data$hs_zbmi_who_binary <- ifelse(selected_metabolomics_data$hs_zbmi_who > median_value, 1, 0)

set.seed(101)
trainIndex <- createDataPartition(selected_metabolomics_data$hs_zbmi_who_binary, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- selected_metabolomics_data[trainIndex,]
test_data  <- selected_metabolomics_data[-trainIndex,]

x_train <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, train_data)[,-1]
y_train <- train_data$hs_zbmi_who_binary
x_test <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, test_data)[,-1]
y_test <- test_data$hs_zbmi_who_binary

# fit enet model using cross-validation
enet_model <- cv.glmnet(x_train, y_train, alpha = 0.5, family = "binomial")
plot(enet_model)

best_lambda <- enet_model$lambda.min
cat("Best Lambda:", best_lambda, "\n")

coef(enet_model, s = best_lambda)

enet_predictions <- predict(enet_model, s = best_lambda, newx = x_test, type = "response")

# convert probabilities to binary predictions
binary_predictions <- ifelse(enet_predictions > 0.5, 1, 0)

# make sure levels match between binary_predictions and y_test
binary_predictions <- factor(binary_predictions, levels = c(0, 1))
y_test <- factor(y_test, levels = c(0, 1))

# accuracy accuracy
accuracy <- mean(binary_predictions == y_test)
cat("Ridge Accuracy on Test Set:", accuracy, "\n")

conf_matrix <- confusionMatrix(binary_predictions, y_test)
conf_matrix

# ROC Curve and AUC
roc_curve <- roc(as.numeric(y_test), as.numeric(enet_predictions))
plot(roc_curve, main = "ROC Curve for Elastic Net Model")
auc_value <- auc(roc_curve)
cat("Elastic Net AUC on Test Set:", auc_value, "\n")
```

## Random Forest

```{r rand forest predictions}
set.seed(101)
rf_model <- randomForest(hs_zbmi_who ~ . -hs_zbmi_who_binary, data = train_data, ntree = 500)

rf_predictions <- predict(rf_model, newdata = test_data)

rf_mse <- mean((rf_predictions - y_test)^2)
cat("Random Forest Mean Squared Error on Test Set:", rf_mse, "\n")

importance(rf_model)
varImpPlot(rf_model)
```

```{r ROC and AUC, warning = FALSE}
# ROC Curve and AUC
roc_curve <- roc(as.numeric(as.character(y_test)), as.numeric(as.character(rf_predictions)))
plot(roc_curve, main = "ROC Curve for Random Forest Model")
auc_value <- auc(roc_curve)
cat("Random Forest AUC on Test Set:", auc_value, "\n")
```

```{r rf sensitivity-specificity , warning = FALSE}
selected_metabolomics_data <- selected_metabolomics_data %>% na.omit()

# hs_zbmi_who to binary based on median
median_value <- median(selected_metabolomics_data$hs_zbmi_who, na.rm = TRUE)
selected_metabolomics_data$hs_zbmi_who_binary <- ifelse(selected_metabolomics_data$hs_zbmi_who > median_value, 1, 0)
selected_metabolomics_data$hs_zbmi_who_binary <- factor(selected_metabolomics_data$hs_zbmi_who_binary, levels = c(0, 1), labels = c("0", "1"))

set.seed(101)
trainIndex <- createDataPartition(selected_metabolomics_data$hs_zbmi_who_binary, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- selected_metabolomics_data[trainIndex,]
test_data  <- selected_metabolomics_data[-trainIndex,]

x_train <- model.matrix(hs_zbmi_who_binary ~ . , train_data)[,-1]
y_train <- train_data$hs_zbmi_who_binary
x_test <- model.matrix(hs_zbmi_who_binary ~ . , test_data)[,-1]
y_test <- test_data$hs_zbmi_who_binary

set.seed(101)
rf_model <- randomForest(hs_zbmi_who_binary ~ . -hs_zbmi_who, data = train_data, ntree = 500)

rf_predictions_prob <- predict(rf_model, newdata = test_data, type = "prob")[,2]
rf_predictions <- predict(rf_model, newdata = test_data)

rf_mse <- mean((as.numeric(as.character(rf_predictions)) - as.numeric(as.character(y_test)))^2)
cat("Random Forest Mean Squared Error on Test Set:", rf_mse, "\n")

importance(rf_model)
varImpPlot(rf_model)

# ROC Curve and AUC
roc_curve <- roc(as.numeric(as.character(y_test)), as.numeric(as.character(rf_predictions_prob)))
plot(roc_curve, main = "ROC Curve for Random Forest Model")
auc_value <- auc(roc_curve)
cat("Random Forest AUC on Test Set:", auc_value, "\n")

conf_matrix <- confusionMatrix(rf_predictions, y_test)
print(conf_matrix)
```

## GBM

```{r gbm predictions, warning = FALSE}
set.seed(101)
gbm_model <- gbm(hs_zbmi_who ~ . - hs_zbmi_who_binary, data = train_data, 
                 distribution = "gaussian",
                 n.trees = 1000,
                 interaction.depth = 3,
                 n.minobsinnode = 10,
                 shrinkage = 0.01,
                 cv.folds = 5,
                 verbose = TRUE)
best_trees <- gbm.perf(gbm_model, method = "cv")
gbm_predictions <- predict(gbm_model, newdata = test_data, n.trees = best_trees)
gbm_mse <- mean((gbm_predictions - y_test)^2)
cat("GBM Mean Squared Error on Test Set:", gbm_mse, "\n")

gbm_importance <- summary(gbm_model)
print(gbm_importance)
```

## Group LASSO

### With Metabolomics

```{r group lasso metabol, warning = FALSE}
selected_metabolomics_data <- selected_metabolomics_data %>% na.omit()

median_value <- median(selected_metabolomics_data$hs_zbmi_who, na.rm = TRUE)
selected_metabolomics_data$hs_zbmi_who_binary <- ifelse(selected_metabolomics_data$hs_zbmi_who > median_value, 1, 0)

set.seed(101)
trainIndex <- caret::createDataPartition(selected_metabolomics_data$hs_zbmi_who_binary, p = .7, list = FALSE, times = 1)
train_data <- selected_metabolomics_data[trainIndex,]
test_data <- selected_metabolomics_data[-trainIndex,]

train_data_clean <- train_data[complete.cases(train_data), ]
test_data_clean <- test_data[complete.cases(test_data), ]

x_train <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, data = train_data_clean)[, -1]
y_train <- as.numeric(train_data_clean$hs_zbmi_who_binary)

x_test <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, data = test_data_clean)[, -1]
y_test <- as.numeric(test_data_clean$hs_zbmi_who_binary)

num_chemicals <- length(chemicals_selected)
num_diet <- length(diet_selected)
num_metabolomics <- ncol(metabol_serum_transposed) - 1  # Excluding ID
num_covariates <- ncol(outcome_and_cov) - 3  # Excluding ID and outcome

# Combine all the lengths
total_length <- num_chemicals + num_diet + num_metabolomics + num_covariates
cat("Total length of predictors:", total_length, "\n")
cat("Number of predictors in x_train:", ncol(x_train), "\n")

group_indices <- c(
  rep(1, num_chemicals),  # Group 1: Chemicals
  rep(2, num_diet),       # Group 2: Postnatal diet
  rep(3, num_metabolomics), # Group 3: Metabolomics (excluding ID)
  rep(4, num_covariates)  # Group 4: Covariates (excluding ID and outcome)
)

if (length(group_indices) < ncol(x_train)) {
  group_indices <- c(group_indices, rep(5, ncol(x_train) - length(group_indices)))
} else if (length(group_indices) > ncol(x_train)) {
  group_indices <- group_indices[1:ncol(x_train)]
}

cat("Length of group_indices:", length(group_indices), "\n")
cat("Number of columns in x_train:", ncol(x_train), "\n")

group_lasso_model <- grplasso(x_train, y_train, index = group_indices, lambda = 0.1, model = LogReg())
coef(group_lasso_model)

group_lasso_predictions <- predict(group_lasso_model, newdata = x_test, type = "response")
# convert probabilities to binary predictions
binary_predictions <- ifelse(group_lasso_predictions > 0.5, 1, 0)

accuracy <- mean(binary_predictions == y_test)
cat("Group LASSO Accuracy on Test Set:", accuracy, "\n")

conf_matrix <- confusionMatrix(factor(binary_predictions), factor(y_test))
conf_matrix

# ROC Curve and AUC
roc_curve <- roc(y_test, group_lasso_predictions)
plot(roc_curve, main = "ROC Curve for Group LASSO Model (with metabolomics)")
auc_value <- auc(roc_curve)
cat("Group LASSO AUC on Test Set:", auc_value)
```

### Without Metabolomics

```{r group lasso without metabol, warning=FALSE}
finalized_data <- finalized_data %>% na.omit()

median_value <- median(finalized_data$hs_zbmi_who, na.rm = TRUE)
finalized_data$hs_zbmi_who_binary <- ifelse(finalized_data$hs_zbmi_who > median_value, 1, 0)

set.seed(101)
trainIndex <- createDataPartition(finalized_data$hs_zbmi_who_binary, p = .7, list = FALSE, times = 1)
train_data <- finalized_data[trainIndex,]
test_data  <- finalized_data[-trainIndex,]

train_data_clean <- train_data[complete.cases(train_data), ]

x_train <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, data = train_data_clean)[,-1]
y_train <- as.numeric(train_data_clean$hs_zbmi_who_binary)

test_data_clean <- test_data[complete.cases(test_data), ]

x_test <- model.matrix(hs_zbmi_who_binary ~ . - hs_zbmi_who, data = test_data_clean)[,-1]
y_test <- as.numeric(test_data_clean$hs_zbmi_who_binary)

num_chemicals <- length(chemicals_selected)
num_diet <- length(diet_selected)
num_covariates <- ncol(outcome_and_cov) - 2  # excluding outcome and binary outcome

total_length <- num_chemicals + num_diet + num_covariates

group_indices <- c(
    rep(1, num_chemicals),  # Group 1: Chemicals
    rep(2, num_diet),  # Group 2: Postnatal diet
    rep(3, num_covariates)  # Group 3: Covariates (excluding outcome)
)

length(group_indices) == ncol(x_train)

# adjust length if necessary
if (length(group_indices) < ncol(x_train)) {
    group_indices <- c(group_indices, rep(4, ncol(x_train) - length(group_indices)))
}

length(group_indices) == ncol(x_train)

group_lasso_model <- grplasso(x_train, y_train, index = group_indices, lambda = 0.1, model = LogReg())
group_lasso_coef <- coef(group_lasso_model)
print(group_lasso_coef)

group_lasso_predictions <- predict(group_lasso_model, newdata = x_test, type = "response")
binary_predictions <- ifelse(group_lasso_predictions > 0.5, 1, 0)

accuracy <- mean(binary_predictions == y_test)
cat("Group LASSO Accuracy on Test Set:", accuracy, "\n")

conf_matrix <- confusionMatrix(factor(binary_predictions), factor(y_test))
conf_matrix

roc_curve <- roc(y_test, group_lasso_predictions)
plot(roc_curve, main = "ROC Curve for Group LASSO Model (without metabolomics)")
auc_value <- auc(roc_curve)
cat("Group LASSO AUC on Test Set:", auc_value, "\n")
```

